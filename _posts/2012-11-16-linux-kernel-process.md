---
date: 2012-11-16 02:28:59+00:00
layout: post
title: Linux内核设计与实现-进程内存使用 
---

```c++
int main(int argc, char *argv[])
{
  while (1) {
  };
  return 0;
}
```

用pmap 进程号 -d 来查看进程

    Address           Kbytes Mode  Offset           Device    Mapping
    0000000000400000       4 r-x-- 0000000000000000 4f9:2c566 a.out
    0000000000500000       4 rw--- 0000000000000000 4f9:2c566 a.out
    000000302ad00000      84 r-x-- 0000000000000000 008:00002 ld-2.3.4.so
    000000302ae14000       8 rw--- 0000000000014000 008:00002 ld-2.3.4.so
    000000302af00000    1196 r-x-- 0000000000000000 008:00002 libc-2.3.4.so
    000000302b02b000    1020 ----- 000000000012b000 008:00002 libc-2.3.4.so
    000000302b12a000      12 r---- 000000000012a000 008:00002 libc-2.3.4.so
    000000302b12d000      12 rw--- 000000000012d000 008:00002 libc-2.3.4.so
    000000302b130000      16 rw--- 000000302b130000 000:00000   [ anon ]
    00002ae829a73000       4 rw--- 00002ae829a73000 000:00000   [ anon ]
    00002ae829a87000       8 rw--- 00002ae829a87000 000:00000   [ anon ]
    00007fff81022000      84 rw--- 00007fff81022000 000:00000   [ stack ]
    ffffffffff600000       4 r-x-- 0000000000000000 000:00000   [ anon ]
    mapped: 2456K    writeable/private: 136K    shared: 0K

    这里的顺序就是进程的地址空间中各个区域的顺序
第一行 a.out 的代码段 执行权限是r-x
第二行 a.out 的数据段 执行权限是rw-
然后是mapped file
ld的代码段 执行权限r-x
ld的数据段 执行权限rw-
libc库代码段 执行权限r-w
libc库这个我也不太清楚
libc库....
libc库的数据段 执行权限rw-

接下来有三行的anon, 分别是a.out, ld, libc 的BSS段, BSS段映射文件的内存区域的设备标志为000:00000 这个区域是0页,0页映射的内容全部为零.因为bss段是未初始化的全局变量区,在进程里面未初始化数据区存的都是0.操作系统有写时复制机制,这样子真正有修改的时候,才会从物理内存中获得空间.

该进程全部地址空间2456K, 可写空间136K.不可写区域可以和其他进程共享,所以多个进程都共享libc库,以及内核的代码.所以物理内存里面只需要保存一份libc库的代码节省了大量的空间

