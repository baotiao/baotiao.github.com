<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>InnoDB DDL 介绍 &#8211; baotiao</title>
    <link rel="dns-prefetch" href="//maxcdn.bootstrapcdn.com">
    <link rel="dns-prefetch" href="//cdn.mathjax.org">
    <link rel="dns-prefetch" href="//cdnjs.cloudflare.com">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="InnoDB DDL 介绍">
    <meta name="robots" content="all">
    <meta name="author" content="baotiao">
    <meta name="keywords" content="">
    <link rel="canonical" href="http://localhost:4000/2020/02/02/innodb-ddl/">
    <link rel="alternate" type="application/rss+xml" title="RSS Feed for baotiao" href="/feed.xml" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/pixyll.css?202204222047" type="text/css">

    <!-- Fonts -->
    
    <link href='//fonts.googleapis.com/css?family=Merriweather:900,900italic,300,300italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Lato:900,300' rel='stylesheet' type='text/css'>
    
    

    <!-- MathJax -->
    

    <!-- Verifications -->
    
    

    <!-- Open Graph -->
    <!-- From: https://github.com/mmistakes/hpstr-jekyll-theme/blob/master/_includes/head.html -->
    <meta property="og:locale" content="en_US">
    <meta property="og:type" content="article">
    <meta property="og:title" content="InnoDB DDL 介绍">
    <meta property="og:description" content="做有积累的事情">
    <meta property="og:url" content="http://localhost:4000/2020/02/02/innodb-ddl/">
    <meta property="og:site_name" content="baotiao">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary" />
    
        <meta name="twitter:site" content="@baotiao" />
    
    <meta name="twitter:title" content="InnoDB DDL 介绍" />
    <meta name="twitter:description" content="InnoDB DDL 介绍" />
    <meta name="twitter:url" content="http://localhost:4000/2020/02/02/innodb-ddl/" />

    <!-- Icons -->
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
    <link rel="icon" type="image/png" href="/favicon-192x192.png" sizes="192x192">
    <link rel="icon" type="image/png" href="/favicon-160x160.png" sizes="160x160">
    <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
    <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
    <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">

    
</head>

<body class="site">
  
	

  <div class="site-wrap">
    <header class="site-header px2 px-responsive">
  <div class="mt2 wrap">
    <div class="measure">
      <a href="http://localhost:4000" class="site-title">baotiao</a>
      <nav class="site-nav">
        
    

    
        <a href="/about/">About</a>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    


    

    

    

    

    
        <a href="/links/">Links</a>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    


    

    

    

    

    

    
        <a href="/paper/">Paper</a>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    


      </nav>
      <div class="clearfix"></div>
      
    </div>
  </div>
</header>


    <div class="post p2 p-responsive wrap" role="main">
      <div class="measure">
        


<div class="post-header mb2">
  <h1>InnoDB DDL 介绍</h1>
  <span class="post-meta">Feb 2 2020</span><br>
  
  <span class="post-meta small">
  
    3 minute read
  
  </span>
</div>

<article class="post-content">
  <h3 id="innodb-ddl">InnoDB DDL</h3>

<p><strong>DDL 主要流程</strong></p>

<ol>
  <li>在prepare phase 阶段, 需要对要进行DDL 的table 加 X mdl</li>
  <li>根据这次要执行的DDL 语句, 创建一个新的schema 的table1, 然后放掉x mdl</li>
  <li>然后如果是Copy algorithm那么就每次从老的table 拷贝到新的table1, 如果是inplace algorithm, 那么每次就inplace 的修改每一行数据的内容. 期间如果有DML 操作, 如果是读取, 就正常读取, 如果是写入, 那么就把写入的内容记录到row_log 中</li>
  <li>重新获得table mdl, 然后将row_log 中的记录写入到table1 中, 这个过程需要一直拿着table mdl lock 防止有新数据写入, 因此如果这个时候row_log 中的内容比较多, 那么这个操作会持续一段时间</li>
  <li>将原来的table drop 掉, 然后将table1 rename 成 table</li>
</ol>

<p>DDL 过程中常见的参数:</p>

<p>https://dev.mysql.com/doc/refman/8.0/en/innodb-online-ddl-space-requirements.html</p>

<p><strong>对于 Online DDL 的定义</strong></p>

<p>从mysql5.6开始，很多DDL操作过程都进行了改进，出现了Online DDL。所谓Online DDL就是指这类DDL操作和DML基本上可以不发生冲突(不是绝对不冲突)，表在执行DDL操作时同样可以执行DML操作。mysql5.6时只是部分DDL操作online化，到现在绝大部分DDL都是Online DDL。</p>

<p><strong>我们所说的 Online DDL 其实主要指的是在DDL 的过程中依然是可写的, 非Online DDL 在运行过程中, 一般是不可写的.</strong></p>

<p><strong>不管是否Online, DDL 的过程中, 数据都是可以访问的.</strong></p>

<p>在做DDL 的时候 一般分成INPLACE 和 COPY 两种方式, 通过在Alter 语句的时候执行algorithm 来指定</p>

<ul>
  <li>COPY  需要拷贝原始表, 所以不允许写操作</li>
  <li>Inplace 不需要拷贝原始表, 直接在当前的表上进行, 可以节省大量的IO
    <ul>
      <li>Online DDL  可以写</li>
      <li>非Online DDL  不可写</li>
    </ul>
  </li>
</ul>

<p>在DDL 选择inplace 的时候, 才会有选项是否支持Online(代码中实现其实是在Inplace 的时候, 通过row_log 记录DDL 过程中插入的数据, 在DDL 结束以后回放row_log 中的数据来实现).</p>

<p>所以如果选择copy table 的方式进行DDL, 那肯定是无法Online 的, 也就是不可写, 只可读的.</p>

<p>一般来说inplace 方式DDL 都是Online,  但是有时候虽然是inplace 的方式, 但是还是需要copy table的</p>

<p>对于不同的DDL 类型, 我们主要关注4个维度</p>

<ol>
  <li>In-Place  是否是In-Place 操作, 目前大部分DDL 操作已经是In-Place 操作了</li>
  <li>copy table  是否需要copy-table, 是否需要重建表, 一般in-place 操作都不需要重建表, 但是有些操作, 比如修改列顺序, 删除列, 添加列这些操作虽然是in-place, 但是还是需要重建表.   其实是否需要copy table 主要是因为cluster index 里面的leaf-node 保存的是具体的数据, 所以加了列, 那么肯定需要把cluster index 里面的数据整理.  所以考虑是否需要copy table 的时候, 我们想想cluster index 里面的数据是否要重新整理就知道了</li>
  <li>Allows Concurrent DML  是否允许写,  inplace DDL 一般都允许写, non-inplace 一般不允许写</li>
  <li>Allows Concurrent Query  DDL 过程一直都是允许读的</li>
</ol>

<table>
  <thead>
    <tr>
      <th>Operation</th>
      <th>In-Place?</th>
      <th>Copies Table?</th>
      <th>Allows Concurrent DML?</th>
      <th>Allows Concurrent Query?</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>添加索引</td>
      <td>Yes*</td>
      <td>No*</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>对全文索引的一些限制</td>
    </tr>
    <tr>
      <td>删除索引</td>
      <td>Yes</td>
      <td>No</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>仅修改表的元数据</td>
    </tr>
    <tr>
      <td>OPTIMIZE TABLE</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>从 5.6.17开始使用ALGORITHM=INPLACE，当然如果指定了<code class="language-plaintext highlighter-rouge">old_alter_table=1</code>或mysqld启动带<code class="language-plaintext highlighter-rouge">--skip-new</code>则将还是COPY模式。如果表上有全文索引只支持COPY</td>
    </tr>
    <tr>
      <td>对一列设置默认值</td>
      <td>Yes</td>
      <td>No</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>仅修改表的元数据</td>
    </tr>
    <tr>
      <td>对一列修改auto-increment 的值</td>
      <td>Yes</td>
      <td>No</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>仅修改表的元数据</td>
    </tr>
    <tr>
      <td>添加 foreign key constraint</td>
      <td>Yes*</td>
      <td>No*</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>为了避免拷贝表，在约束创建时会禁用foreign_key_checks</td>
    </tr>
    <tr>
      <td>删除 foreign key constraint</td>
      <td>Yes</td>
      <td>No</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>foreign_key_checks 不影响</td>
    </tr>
    <tr>
      <td>改变列名</td>
      <td>Yes*</td>
      <td>No*</td>
      <td>Yes*</td>
      <td>Yes</td>
      <td>为了允许DML并发, 如果保持相同数据类型，仅改变列名</td>
    </tr>
    <tr>
      <td>添加列</td>
      <td>Yes*</td>
      <td>Yes*</td>
      <td>Yes*</td>
      <td>Yes</td>
      <td>尽管允许 ALGORITHM=INPLACE ，但数据大幅重组，所以它仍然是一项昂贵的操作。当添加列是auto-increment，不允许DML并发</td>
    </tr>
    <tr>
      <td>删除列</td>
      <td>Yes</td>
      <td>Yes*</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>尽管允许 ALGORITHM=INPLACE ，但数据大幅重组，所以它仍然是一项昂贵的操作</td>
    </tr>
    <tr>
      <td>修改列数据类型</td>
      <td>No</td>
      <td>Yes*</td>
      <td>No</td>
      <td>Yes</td>
      <td>修改类型或添加长度，都会拷贝表，而且不允许更新操作</td>
    </tr>
    <tr>
      <td>更改列顺序</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>尽管允许 ALGORITHM=INPLACE ，但数据大幅重组，所以它仍然是一项昂贵的操作</td>
    </tr>
    <tr>
      <td>修改ROW_FORMAT  和KEY_BLOCK_SIZE</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>尽管允许 ALGORITHM=INPLACE ，但数据大幅重组，所以它仍然是一项昂贵的操作</td>
    </tr>
    <tr>
      <td>设置列属性NULL 或NOT NULL</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>尽管允许 ALGORITHM=INPLACE ，但数据大幅重组，所以它仍然是一项昂贵的操作</td>
    </tr>
    <tr>
      <td>添加主键</td>
      <td>Yes*</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>尽管允许 ALGORITHM=INPLACE ，但数据大幅重组，所以它仍然是一项昂贵的操作。 如果列定义必须转化NOT NULL，则不允许INPLACE</td>
    </tr>
    <tr>
      <td>删除并添加主键</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>在同一个 ALTER TABLE 语句删除就主键、添加新主键时，才允许inplace；数据大幅重组,所以它仍然是一项昂贵的操作。</td>
    </tr>
    <tr>
      <td>删除主键</td>
      <td>No</td>
      <td>Yes</td>
      <td>No</td>
      <td>Yes</td>
      <td>不允许并发DML，要拷贝表，而且如果没有在同一 ATLER TABLE 语句里同时添加主键则会收到限制</td>
    </tr>
    <tr>
      <td>变更表字符集</td>
      <td>No</td>
      <td>Yes</td>
      <td>No</td>
      <td>Yes</td>
      <td>如果新的字符集编码不同，重建表</td>
    </tr>
  </tbody>
</table>

<p>online DDL 主要包含3个阶段</p>

<ol>
  <li>
    <p>prepare 阶段</p>

    <p>执行函数 ha_prepare_inplace_alter_table 最后执行到 InnoDB 中 ha_innobase::prepare_inplace_alter_table =&gt; prepare_inplace_alter_table_impl =&gt; prepare_inplace_alter_table_dict</p>
  </li>
  <li>
    <p>ddl 阶段</p>

    <p>执行函数 ha_inplace_alter_table 最后执行到InnoDB 中</p>

    <p>ha_innobase::inplace_alter_table</p>
  </li>
  <li>
    <p>commit 阶段</p>

    <p>执行函数 ha_commit_inplace_alter_table  最后执行到InnoDB 中handler0alter.cc ha_innobase::commit_inplace_alter_table</p>
  </li>
</ol>

<h4 id="最常见的场景-增加一个index-的时候-代码的执行流程">最常见的场景, 增加一个index 的时候, 代码的执行流程</h4>

<p>在create index 的时候, 主要流程</p>

<ol>
  <li>
    <p>row0merge.c::row_merge_create_index();  // 创建新的索引所需要的索引结构信息, 创建内存结构体 dict_index_t</p>
  </li>
  <li>
    <p>row0merge.c::row_merge_build_indexes();  // 读取cluster index, 然后对读取到的文件排序, 最后插入到新的索引结构中</p>

    <p>​	1. row_merge_read_clustered_index();</p>

    <p>​	2. row_merge_sort();</p>

    <p>​	3. row_merge_insert_index_tuples();</p>

    <p>三个步骤对应建立索引的3个阶段</p>

    <ol>
      <li>读取阶段: 读cluster index</li>
      <li>排序阶段: 对索引临时文件进行排序</li>
      <li>建立阶段: 插入记录建索引</li>
    </ol>
  </li>
  <li>
    <p>row0log.cc::row_log_table_apply 在完成这3个步骤以后, 因为Online DDL 的同时是还允许用户写入, 因为在将DDL 开始前的数据都插入到新的索引, 还需要将在DDL期间的数据也要插入到新的索引.</p>

    <p>在Online DDL 实现中, 将DDL 期间新插入的数据写入到 row_log 中, 那么DDL 完成后, 需要将row_log 中的数据进行apply</p>

    <p>在Online create index 的时候, 增加了row log 相关的操作.</p>
  </li>
</ol>

<p><strong>copy DDL</strong></p>

<p>copy ddl首尾加mdl x锁，中间执行阶段加的mdl锁不允许写，允许读</p>

<p>而online ddl 首尾加mdl xlock, 中间执行阶段不加mdl 锁. 所以是允许写的</p>

<p><strong>Aurora fast DDL 的核心思路</strong></p>

<p>Aurora support fast DDL, 其实我理解fast DDL 类似实现了多版本的 dd 信息.</p>

<p>https://aws.amazon.com/blogs/database/amazon-aurora-under-the-hood-fast-ddl/</p>

<p>Moving them to parallel, background, and asynchronous execution makes a difference.</p>

<p>将DDL 这个同步操作 改成 并行, 并行在后台执行的异步操作来实现 fast DDL</p>

<p><strong>我理解fast ddl 是目前共享存储架构必须实现的一套方案, 因为ro, rw 共享一套数据了, 那么rw 必然需要和ro 共享一份DD 数据, 因此想做DDL 只能阻止ro 访问了, 这个实现更值得做了</strong></p>

<p>那么fast DDL是怎么做的呢?</p>

<ol>
  <li>
    <p>首先在发起 DDL 操作以后, database 只需要更新了 information_schema 里面的表结构信息, 这里是支持多版本的 information_schema, 增加了一个新版本, 然后把这个通知给所有的 replica</p>

    <p>这样前台的同步操作就完成了, 后续都是异步后台的操作了</p>
  </li>
  <li>
    <p>那么接下来如果有 DML 操作,  会先看要访问的page schema是否有一个还没有执行完成的 DDL 操作.  比较的方法是通过比较这个page 的lsn 和最新的schema 信息比较, 如果比较小, 那么说明这个page 是老大, 需要更新到最新的schema.  这个时候, 可以当独对page apply 最新版本的schema 信息. 返回给DML 操作.</p>

    <p>对于没有被DML 操作访问到的page 则在后台慢慢更新这些page</p>

    <p>这些page 被DML 操作更新以后, 如果发生SMO 操作了, 那该如何处理?</p>

    <p>TODO(baotiao), 必须小心处理</p>

    <p>同样, 对于replica 因为replica 不可能修改数据, 因此默认让replica 都访问最新版本数据, 当DML 操作带上对page 访问的版本号以后, 只要不发生SMO 操作, 都可以根据page 找到老版本的redo log 信息</p>
  </li>
</ol>

<p>这里涉及修改的地方比较多得是</p>

<ol>
  <li>
    <p>每一个record 标记自己属于哪一个版本的 dd</p>
  </li>
  <li>
    <p>InnoDB 的record 是通过undo 来实现, 并不是pg 里面直接拷贝一份数据, 所以一个record 的多版本就需要在Undo 里面去做.</p>
  </li>
  <li>
    <p>建立二级索引这种需求, 如果一些record 一直没有被访问到, 那么数据一直是老版本的, 这个时候建立index 没有这个字段怎么处理</p>
  </li>
  <li>
    <p>还有对性能的影响怎么处理? 目前dd 信息都存在内存里面,  直接访问最新的就可以, 如果dd 版本过多, 那么是不是设计到IO 操作了</p>
  </li>
</ol>

<p><strong>server 层代码路径:</strong></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#0  mysql_alter_table (thd=thd@entry=0x7fd72c000b50, new_db=0x7fd72c2e6380 "test", new_name=0x0, create_info=create_info@entry=0x7fe05afa2580,
</span>    <span class="n">table_list</span><span class="o">=</span><span class="n">table_list</span><span class="err">@</span><span class="n">entry</span><span class="o">=</span><span class="mh">0x7fd72c2e5dd8</span><span class="p">,</span> <span class="n">alter_info</span><span class="o">=</span><span class="n">alter_info</span><span class="err">@</span><span class="n">entry</span><span class="o">=</span><span class="mh">0x7fe05afa2680</span><span class="p">)</span> <span class="n">at</span> <span class="o">/</span><span class="n">disk1</span><span class="o">/</span><span class="n">git</span><span class="o">/</span><span class="n">PolarDB_80</span><span class="o">/</span><span class="n">sql</span><span class="o">/</span><span class="n">sql_table</span><span class="p">.</span><span class="n">cc</span><span class="o">:</span><span class="mi">14187</span>
<span class="cp">#1  0x00000000010ba894 in Sql_cmd_alter_table::execute (this=&lt;optimized out&gt;, thd=0x7fd72c000b50) at /disk1/git/PolarDB_80/sql/sql_alter.cc:343
#2  0x0000000000cda7cb in mysql_execute_command (thd=thd@entry=0x7fd72c000b50, first_level=first_level@entry=true)
</span>    <span class="n">at</span> <span class="o">/</span><span class="n">disk1</span><span class="o">/</span><span class="n">git</span><span class="o">/</span><span class="n">PolarDB_80</span><span class="o">/</span><span class="n">sql</span><span class="o">/</span><span class="n">sql_parse</span><span class="p">.</span><span class="n">cc</span><span class="o">:</span><span class="mi">4644</span>
<span class="cp">#3  0x0000000000cdca3f in mysql_parse (thd=thd@entry=0x7fd72c000b50, parser_state=parser_state@entry=0x7fe05afa4420,
</span>    <span class="n">force_primary_storage_engine</span><span class="o">=</span><span class="n">force_primary_storage_engine</span><span class="err">@</span><span class="n">entry</span><span class="o">=</span><span class="nb">false</span><span class="p">)</span> <span class="n">at</span> <span class="o">/</span><span class="n">disk1</span><span class="o">/</span><span class="n">git</span><span class="o">/</span><span class="n">PolarDB_80</span><span class="o">/</span><span class="n">sql</span><span class="o">/</span><span class="n">sql_parse</span><span class="p">.</span><span class="n">cc</span><span class="o">:</span><span class="mi">5396</span>
<span class="cp">#4  0x0000000000cdfcf3 in dispatch_command (thd=thd@entry=0x7fd72c000b50, com_data=com_data@entry=0x7fe05afa4be0, command=COM_QUERY)
</span>    <span class="n">at</span> <span class="o">/</span><span class="n">disk1</span><span class="o">/</span><span class="n">git</span><span class="o">/</span><span class="n">PolarDB_80</span><span class="o">/</span><span class="n">sql</span><span class="o">/</span><span class="n">sql_parse</span><span class="p">.</span><span class="n">cc</span><span class="o">:</span><span class="mi">1794</span>
<span class="cp">#5  0x0000000000ce084d in do_command (thd=thd@entry=0x7fd72c000b50) at /disk1/git/PolarDB_80/sql/sql_parse.cc:1288
#6  0x0000000000df5398 in handle_connection (arg=arg@entry=0x5330050) at /disk1/git/PolarDB_80/sql/conn_handler/connection_handler_per_thread.cc:316
#7  0x000000000213352f in pfs_spawn_thread (arg=0x5330110) at /disk1/git/PolarDB_80/storage/perfschema/pfs.cc:2836
#8  0x00007fe06fb82e25 in start_thread () from /lib64/libpthread.so.0
#9  0x00007fe06e172f1d in clone () from /lib64/libc.so.6
</span></code></pre></div></div>

<p>常见的sql 解析过程就是do_command=&gt;dispatch_command=&gt;mysql_parse=&gt;mysql_execute_command, 然后这里解析到了 case SQLCOM_ALTER_TABLE:  就执行alter 相关代码, 带了sql_alter.cc 里面.</p>

<p>在 Sql_cmd_alter_table::execute 里面会执行最长的 mysql_alter_table 语句</p>


</article>






  <div id="disqus_thread"></div>
  <script type="text/javascript">
    var disqus_shortname  = 'baotiao';
    var disqus_identifier = '/2020/02/02/innodb-ddl';
    var disqus_title      = 'InnoDB DDL 介绍';

    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>






      </div>
    </div>
  </div>

  <footer class="center">
</footer>


</body>
</html>
