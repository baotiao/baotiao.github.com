<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="author" content="陈宗志" />
	<title>libevent demo | 陈宗志</title>
    <link rel="shortcut icon" href="/favicon.ico">
    <link href="http://localhost:4000/feed/" rel="alternate" title="陈宗志" type="application/atom+xml" />
    <link rel="stylesheet" href="/media/css/style.css">
    <link rel="stylesheet" href="/media/js/code/desert.css">|
  </head>

	<div id="top"></div>
  <body>
    <div id="container">
      <div id="main" role="main">
        <header>
        <h1>libevent demo</h1>
        </header>

        <nav>
        <span><a title="home page" class="" href="http://localhost:4000/">home</a></span>
        <span><a title="categories" class="" href="http://localhost:4000/categories/">categories</a></span>
        <span><a title="links" class="" href="http://localhost:4000/links/">links</a></span>
        <span><a title="paper" class="" href="http://localhost:4000/paper/">paper</a></span>
        <span><a title="vitae" class="" href="http://localhost:4000/vitae/">vitae</a></span>
        </nav>

        <article class="content">


        <section class="post">
<p>libevent 就是对select的封装.</p>

<p>select 比一般的阻塞调用厉害的地方在于,它能够阻塞在多个调用上.比如read阻塞了以后,程序只能当有新的输入以后,程序才继续运行,socket accept阻塞以后,当socket有请求,这个阻塞才会停止. 而select的叫IO多路复用,就是说调用select 以后可以同时监听这些阻塞.调用select以后,当有新的输入或者有新的socket请求程序都会停止阻塞,继续运行.</p>

<p>read/write 操作</p>

<p>libevent 编译时候加-levent</p>

<p>main 开始的时候event_init();</p>

<p>event_set(struct event <em>ev, int fd, short event, void (</em>fn)(int, short, void <em>), void </em>arg);</p>

<ol>
<li>construct struct event for event_add and event_del, the fourth parameter is the callback function we should implement.</li>
<li>event type: EV_TIMEOUT,EV_SIGNAL,EV_READ,EV_WRITE</li>
</ol>


<p>-->The additional flag EV_PERSIST makes an event_add() persistent until event_del() has been called.
如果没有用EV_PERSIST那么这个时间触发一次以后,这个事件就不再被注册了.所以基本都有EV_PERSIST</p>

<pre><code>event_add(struct event *ev, struct timeval *tv)
event_del(struct event *ev):
add or del an event.

event_dispatch():
In order to process events, an application needs to call it.This function only returns on error, and should replace the event core of the application program.
</code></pre>

<p>表示监听多个event type的时候 用| EV_READ | EV_TIMEOUT</p>

<pre><code>/* 这个是libevent 的一个例子. 先建立一个FIFO,将其设置为非阻塞.注册这个event,
event_set(&amp;evfifo, socket, EV_READ | EV_PERSIST, fifo_read, &amp;evfifo);
意思是监听socket这个描述符的读请求,并且设置EV_PERSIST. 触发以后调用fifo_read这个函数.
等待管道的另一端写数据.
此时在另外一个终端执行echo "heihei" &gt; event.fifo 这个就会输出这个heihei.

#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;signal.h&gt;
#include &lt;event.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;fcntl.h&gt;

void fifo_read(int fd, short event, void *arg)
{
    char buf[255];
    int len;
    struct event *ev = arg;
    static int count = 0;

    /* Reschedule this event */
//    event_add(ev, NULL);

    fprintf(stderr, "fifo_read called with fd: %d, event: %d, arg: %p\n",
        fd, event, arg);
    if (++count == 20) {
        len = read(fd, buf, sizeof(buf) - 1);

        if (len == -1) {
            perror("read");
            return;
        } else if (len == 0) {
            fprintf(stderr, "Connection closed\n");
            return;
        }

        buf[len] = '\0';
        fprintf(stdout, "Read: %s\n", buf);
    }
printf("over...\n");
}

int main()
{
    struct event evfifo;
    char* fifo = "event.fifo";

    unlink(fifo);
    if (mkfifo(fifo, 0777) == -1) {
        perror("mkfifo");
        exit(1);
    }

    int socket = open(fifo, O_RDWR | O_NONBLOCK, 0);
    if (socket == -1) {
        perror("open");
        exit(1);
    }

    fprintf(stderr, "Write data to %s\n", fifo);
    event_init();
    /* Initalize one event */
    event_set(&amp;evfifo, socket, EV_READ | EV_PERSIST, fifo_read, &amp;evfifo);
    /* Add it to the active events, without a timeout */
    event_add(&amp;evfifo, NULL);

    event_dispatch();

    return 0;
}
</code></pre>

<p>今天做了一堆的实验 可以得出一些结论:</p>

<ol>
<li><p>libevent 的event_base是基于线程的.也就是说一个thread只能有一个event_base.如果有多个event_base 那么后来的event_base则会跑到栈的开头,等这个event_base结束以后,这个event_base会结束,原来的event_base又会顶上来. 表现出来的就是 如果在call_accept 里面新建立一个event_base.那么 当telnet成功连接一次,新过来的telnet的连接就不会进入到call_accept这个事件里面.</p></li>
<li><p>event_base_loop 启动以后,就不能再往这个event_base添加新的事件了.添加了以后会segmentfault.</p></li>
<li><p>基于上面这种情况,所以单线程实现不了能够为多个telnet 提供call_accept的服务. 只能一个telnet->call_accept->str_echo 然后再处理一个新的telnet的请求.</p>

<p> 所以想实现这种为多个telnet 提供服务的,要做成多thread这种,然后每个thread有一个自己的event_base.然后就telnet 连接成功以后的 sfd 传给每个线程,让每个线程在自己的event_base里面监听这个sfd的输入.</p></li>
<li><p>还有就是 在memcached里面,dispatch_thread 往 work_thread 写入1个字节的数据.这个时候如果work_thread在忙,没有办法立刻处理这个事件会怎么办. libevent是这样做的. 在dispatch_thread 往 work_thread notify_receive_fd 写入事件后, 如果work_thread 正在忙,那么这个事件会保存在改线程的内存空间里面,一旦该线程没有阻塞.那么又会立刻执行这个事件.</p></li>
<li><p>TCP断开连接的过程中client会保持一段时间在TIME_WAIT状态. 因为最后的阶段是srv往cli发一个fin,然后cli返回一个ack给srv. 然后会保持一段时间的TIME_WAIT状态,这个时候如果cli又在这个端口建立新连接会出错.得等会.</p></li>
</ol>


<pre><code>    #include &lt;stdio.h&gt;
    #include &lt;stdlib.h&gt;
    #include &lt;fcntl.h&gt;
    #include &lt;event.h&gt;
    #include &lt;unistd.h&gt;
    #include &lt;netinet/in.h&gt;
    #include &lt;sys/socket.h&gt;
    #include &lt;string.h&gt;
    #include &lt;fcntl.h&gt;

    typedef struct sockaddr * SA;
    struct event_base *main_base;

    void str_echo(int fd, short event, void *arg)
    {
        char buf[100];
        int n;

        n = read(fd, buf, 100);
            fputs("a socket has come\n", stdout);
            write(fd, buf, n);
        if (n &lt; 0) {
            return ;
        }
        return ;
    }
    void call_accept(int fd, short event, void *arg)
    {
        sleep(10);
        printf("come in a new accept\n");
        struct sockaddr_in cliaddr;
        socklen_t clilen;
        int connfd;
        connfd = accept(fd, (struct sockaddr *) &amp;cliaddr, &amp;clilen);
        printf("accept from cliaddr\n");
        char buf[100];
    //    read(fd, buf, 100);
        //str_echo(connfd);
    //    printf("%d\n", (void *)base);
    //    struct event read_ev;
    //    //fcntl(connfd, F_SETFL, O_NONBLOCK);
    //    event_set(&amp;read_ev, connfd, EV_READ, str_echo, &amp;read_ev);
    //    //event_base_set(main_base, &amp;read_ev);
    //    event_add(&amp;read_ev, NULL);

    //    event_base_loop(base, 0);
    }
    int main()
    {
        int listenfd, connfd;
        struct sockaddr_in cliaddr, servaddr;
        socklen_t clilen;

        listenfd = socket(AF_INET, SOCK_STREAM, 0);
        memset(&amp;servaddr, 0, sizeof(servaddr));
        servaddr.sin_family = AF_INET;
        servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
        servaddr.sin_port = htons(9877);
        bind(listenfd, (struct sockaddr *) &amp;servaddr, sizeof(servaddr));
        listen(listenfd, 10);

        struct event ev;
        main_base = event_init();
        event_set(&amp;ev, listenfd, EV_READ | EV_PERSIST, call_accept, &amp;ev);
        //event_base_set(main_base, &amp;ev);
        event_add(&amp;ev, NULL);
        printf("block before accept\n");
        event_base_loop(main_base, 0);    
        printf("after event_dispatch\n");
        return 0;
    }
</code></pre>

</section>
<section class="meta">
<span class="author">
  <a href="http://baotiao.github.io/">陈宗志</a>
</span>
<span class="time">
  /
  <time datetime="2012-01-31">2012-01-31</time>
</span>
<br />
<span class="license">
  Published under <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">(CC) BY-NC-SA</a>
</span>

<span class="categories">
  in categories
  
  <a href="http://localhost:4000/categories/#tech" title="tech">tech</a>&nbsp;
  
</span>


<span class="tags">
  tagged with 
  
  <a href="http://localhost:4000/tags/#network" title="network">network</a>&nbsp;
  
  <a href="http://localhost:4000/tags/#libevent" title="libevent">libevent</a>&nbsp;
  
  <a href="http://localhost:4000/tags/#c++" title="c++">c++</a>&nbsp;
  
</span>

</section>

<div class="bshare-custom"><a title="åäº«å°æ°æµªå¾®å" class="bshare-sinaminiblog"></a><a title="åäº«å°Facebook" class="bshare-facebook"></a><a title="åäº«å°Twitter" class="bshare-twitter"></a><a title="æ´å¤å¹³å°" class="bshare-more bshare-more-icon more-style-addthis"></a></div><script type="text/javascript" charset="utf-8" src="http://static.bshare.cn/b/buttonLite.js#style=-1&amp;uuid=17304268-f570-4255-9088-f5132e6fd01b&amp;pophcol=1&amp;lang=zh"></script><script type="text/javascript" charset="utf-8" src="http://static.bshare.cn/b/bshareC0.js"></script>
<section class="comment">
<div id="disqus_thread"></div>
<script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'baotiao'; // required: replace example with your forum shortname
		var disqus_rul = 'http://localhost:4000/2012/01/libevent-demo/';

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
</section>

<script type="text/javascript">
$(function(){
  $(document).keydown(function(e) {
    if (e.target.nodeName.toUpperCase() != 'BODY') return;
    var url = false;
        if (e.which == 37 || e.which == 74) {  // Left arrow and J
            
        url = 'http://localhost:4000/2012/01/echo-server-client/';
        
        }
        else if (e.which == 39 || e.which == 75) {  // Right arrow and K
            
        url = 'http://localhost:4000/2012/02/memcached-thread-model/';
        
        }
        if (url) {
            window.location = url;
        }
  });
})
</script>



        </article>

	<div id="message"><a href="#top">Scroll to top</a></div>
	</div>
</div>

<script type="text/javascript" src="/media/js/jquery-1.7.1.min.js"></script>
<script type="text/javascript" src="/media/js/code/prettify.js"></script>

 <script type="text/javascript">
      $(function(){
        $("pre").addClass("prettyprint");
        prettyPrint();
        $('.entry a').each(function(){
          if($(this).attr("href").indexOf("chenzongzhi") == -1){
            $(this).attr("target", "_blank");
          }
        })
      });
</script>


<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-35023741-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>



<script type="text/javascript">
$(function () {

    /* set variables locally for increased performance */
    var scroll_timer;
    var displayed = false;
    var $message = $('#message a');
    var $window = $(window);
    var top = $(document.body).children(0).position().top;

    /* react to scroll event on window */
    $window.scroll(function () {
        window.clearTimeout(scroll_timer);
        scroll_timer = window.setTimeout(function () {
            if($window.scrollTop() <= top + 800)
            {
                displayed = false;
                $message.fadeOut(1000);
            }
            else if(displayed == false)
            {
                displayed = true;
                $message.stop(true, true).show().click(function () { $message.fadeOut(1000); });
            }
        }, 100);
    });
});
</script>
  </body>
</html>
