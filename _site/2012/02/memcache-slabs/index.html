<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="author" content="陈宗志" />
	<title>Memcache 内存分配 | 陈宗志</title>
    <link rel="shortcut icon" href="/favicon.ico">
    <link href="http://baotiao.github.io/feed/" rel="alternate" title="陈宗志" type="application/atom+xml" />
    <link rel="stylesheet" href="/media/css/style.css">
    <link rel="stylesheet" href="/media/js/code/desert.css">|
  </head>

	<div id="top"></div>
  <body>
    <div id="container">
      <div id="main" role="main">
        <header>
        <h1>Memcache 内存分配</h1>
        </header>

        <nav>
        <span><a title="home page" class="" href="http://baotiao.github.io/">home</a></span>
        <span><a title="categories" class="" href="http://baotiao.github.io/categories/">categories</a></span>
        <span><a title="links" class="" href="http://baotiao.github.io/links/">links</a></span>
        <span><a title="paper" class="" href="http://baotiao.github.io/paper/">paper</a></span>
        <span><a title="vitae" class="" href="http://baotiao.github.io/vitae/">vitae</a></span>
        </nav>

        <article class="content">


        <section class="post">
<p>内存分配主要在slab.c里面实现.
slabclass 的数据结构</p>

<pre><code>typedef struct {
    unsigned int size;      /* sizes of items */  每一个chunk的大小
    unsigned int perslab;   /* how many items per slab */ 每一个slab包含的chunk的数目

    void **slots;           /* list of item ptrs */ 是当前slab class的空闲的chunk块指针数组    
    unsigned int sl_total;  /* size of previous array */ 已分配的slots数据的大小
    unsigned int sl_curr;   /* first free slot */ 当前可用的slots数组的索引

    void *end_page_ptr;         /* pointer to next free item at end of page, or 0 */ //这个指针指向最新的那个page可用的chunk处
    unsigned int end_page_free; /* number of items remaining at end of last alloced page */ //这个是新的那个page里面可用的chunk的个数,如果*end_page_prt != NUll 并且 end_page_free == 0 说明最后一个page也被填满数据了.

    unsigned int slabs;     /* how many slabs were allocated for this class */ //这个是当前已使用的slab_list的数量

    void **slab_list;       /* array of slab pointers */ //这个是所有的page的list, 每新添加一个page.
    unsigned int list_size; /* size of prev array */ //slab_list指针数组已分配的大小

    unsigned int killing;  /* index+1 of dying slab, or zero if none */
    size_t requested; /* The number of requested bytes */
} slabclass_t;
</code></pre>

<p>slabs 模型. (网上找的,我觉得表示最好的一张图,结合图看下面的函数分析)
<a href="http://chenzongzhi.info/wp-content/uploads/2012/02/slabs.jpeg"><img src="http://chenzongzhi.info/wp-content/uploads/2012/02/slabs.jpeg" alt="" /></a>﻿</p>

<p>几个重要变量</p>

<pre><code>static slabclass_t slabclass[MAX_NUMBER_OF_SLAB_CLASSES];
static size_t mem_limit = 0; //内存限制的大小
static size_t mem_malloced = 0;
static int power_largest;

static void *mem_base = NULL; //分配的整块大内存的位置
static void *mem_current = NULL; //目前可用的内存的位置
static size_t mem_avail = 0; //剩余可用的内存的大小
</code></pre>

<p>函数介绍:</p>

<pre><code>/*
     就是根据传进来的size.找到第一个slab class的size比他大的slab class.返回slab class的id.
*/
unsigned int slabs_clsid(const size_t size) {
    int res = POWER_SMALLEST;

    if (size == 0)
        return 0;
    while (size &gt; slabclass[res].size)
        if (res++ == power_largest)     /* won't fit in the biggest slab */
            return 0;
    return res;
}

/*
     slabs初始化函数,初始化了生成一个链表slabclass.
     slabclass 就是size大小不同的,然后size * perslab = 1M的一个链表,然后在这个链表里面每添加一个slab,这个slab也叫page.也就是不断往这个链表后面添加page.然后每个page里面的有perslab 数的chunk,然后真正的数据是叫item,item存在正好比item大一点的chunk上.
     以后每次添加新的page,都是先找到相应大小的那个类型的slab,然后插入在slabclass这个链表的slab_list的后面
*/

void slabs_init(const size_t limit, const double factor, const bool prealloc) {
    int i = POWER_SMALLEST - 1;
    unsigned int size = sizeof(item) + settings.chunk_size; //初始化最小的slabclass里面的size
    mem_limit = limit;

    if (prealloc) { //选择了prealloc就是预先分配一个大内存 然后初始化mem_base,mem_current,mem_avail.
        /* Allocate everything in a big chunk with malloc */
        mem_base = malloc(mem_limit); //分配mem_limit大小的内存
        if (mem_base != NULL) {
            mem_current = mem_base;
            mem_avail = mem_limit;
        } else {
            fprintf(stderr, "Warning: Failed to allocate requested memory in"
                    " one large chunk.\nWill allocate in smaller chunks\n");
        }
    }

    memset(slabclass, 0, sizeof(slabclass));

    /*
        这里是初始化slabclass链表的过程,根据最小的size.然后size*factor 逐渐加上去
        直到size = 1M 为止
    */
    while (++i &lt; POWER_LARGEST &amp;&amp; size &lt;= settings.item_size_max / factor) {

    省略..
             if (pre_alloc == NULL || atoi(pre_alloc) != 0) {
            slabs_preallocate(power_largest);
          //这个函数是给没一个slabclass都预先分配一个slabs,也就是1M的大小.
          //所以每一个slabclass都会有一个1M大小的空间.不过这样有存在内存浪费,因为有可能有些
          //slabs不会被用到
        }
}

/*
     预先为所有的slabclass分配空间
*/
static void slabs_preallocate (const unsigned int maxslabs) {
    int i;
    unsigned int prealloc = 0;

    /* pre-allocate a 1MB slab in every size class so people don't get
       confused by non-intuitive "SERVER_ERROR out of memory"
       messages.  this is the most common question on the mailing
       list.  if you really don't want this, you can rebuild without
       these three lines.  */

    for (i = POWER_SMALLEST; i &lt;= POWER_LARGEST; i++) {
        if (++prealloc &gt; maxslabs)
            return;
        do_slabs_newslab(i);
    }
}

/*
    调整slabclass的slab_list指针数组,如果为空,这默认分配16个,如果存在,那么*2的增加slab_list数组*/
static int grow_slab_list (const unsigned int id) {
    slabclass_t *p = &amp;slabclass;[id];
    if (p-&gt;slabs == p-&gt;list_size) {  //当slabclass里面的slabs(当前已使用的slab_list的数量)和list_size(已分配的slab_list的数量)相等时,
                                    //表示这个slab_list的已经用完了,需要生成新的slab_list
        size_t new_size =  (p-&gt;list_size != 0) ? p-&gt;list_size * 2 : 16; //如果list_size是空,自&gt;动生成16个,否则就是*2的增长
        void *new_list = realloc(p-&gt;slab_list, new_size * sizeof(void *)); //把这个list realloc到新的空间去
        if (new_list == 0) return 0;
        p-&gt;list_size = new_size;
        p-&gt;slab_list = new_list;
    }
    return 1;
}

/*
    为某一个slabclass分配一个新的slab.真正执行分配一个slab的是memory_allocate函数
    其实memori_alocate函数做的就是从mem_current找到len大小的空间,并返回mem_current的地址
*/
static int do_slabs_newslab(const unsigned int id) {
    slabclass_t *p = &amp;slabclass;[id];
    int len = p-&gt;size * p-&gt;perslab;
    char *ptr;

    /*
        这里判断slab_list这个指针数据大小够不够,不够分配新的空间.
        memory_allocate分配新的大小的空间
    */
    if ((mem_limit &amp;&amp; mem_malloced + len &gt; mem_limit &amp;&amp; p-&gt;slabs &gt; 0) ||
        (grow_slab_list(id) == 0) ||
        ((ptr = memory_allocate((size_t)len)) == 0)) { //在这里声明大小为 1M的page.

        MEMCACHED_SLABS_SLABCLASS_ALLOCATE_FAILED(id);
        return 0;
    }     

    memset(ptr, 0, (size_t)len);
    p-&gt;end_page_ptr = ptr; //将end_page_ptr 也就是表示最新的可用的chunk的指针指向ptr
    p-&gt;end_page_free = p-&gt;perslab; //end_page_free 因为这里是一个全新的page 所以 end_page_free = p-&gt;perslabs
    p-&gt;slab_list[p-&gt;slabs++] = ptr; //将ptr 加入道p-&gt;slab_list里面去,并且 page 的个数++
    mem_malloced += len;
    MEMCACHED_SLABS_SLABCLASS_ALLOCATE(id);

    return 1;
}

/*
    这个是进行给slab分配内存的函数,会判断是否有足够的空间,已经然后将目前的mem_current返回,然后&gt;调整mem_current的值
*/
static void *memory_allocate(size_t size) {
    void *ret;

    if (mem_base == NULL) {
        /* We are not using a preallocated large memory chunk */
        ret = malloc(size);
    } else {
        ret = mem_current;

        if (size &gt; mem_avail) {
            return NULL;
        }

        /* mem_current pointer _must_ be aligned!!! */
        if (size % CHUNK_ALIGN_BYTES) {
            size += CHUNK_ALIGN_BYTES - (size % CHUNK_ALIGN_BYTES);
        }

        mem_current = ((char*)mem_current) + size;

        if (size &lt; mem_avail) {
            mem_avail -= size;
        } else {
            mem_avail = 0;
        }
    }

    return ret;
}
</code></pre>

<p>到此处理slabs已经初始化结束了.memcached还提供了一个空闲item链表,叫slots.就是当一个slabs里面的item已经过期了,那么这个chunk不是退回给内存池,而是放入到这个空闲链表里面去,同样当申请一个新元素的时候也是先判断这个slots数组是否有空间,没有空间再去slabs里面去获得.</p>

<pre><code>static void *do_slabs_alloc(const size_t size, unsigned int id) {
     ..省略..
/*
        这里判断end_page_ptr是否指向可用的chunk, 当前slabclass的slots的空闲chunk个数
        以及是否可以新分配一块slab
        如果可以获得空间的话,先从slabclass的slots里面获得,然后才是从slab里面的end_page_ptr处去&gt;获得
    */
    if (! (p-&gt;end_page_ptr != 0 || p-&gt;sl_curr != 0 ||
           do_slabs_newslab(id) != 0)) {
        /* We don't have more memory available */
        ret = NULL;
    } else if (p-&gt;sl_curr != 0) {
        /* return off our freelist */
        ret = p-&gt;slots[--p-&gt;sl_curr];
    } else {
        /* if we recently allocated a whole page, return from that */
        assert(p-&gt;end_page_ptr != NULL);
        ret = p-&gt;end_page_ptr;
        if (--p-&gt;end_page_free != 0) {
            p-&gt;end_page_ptr = ((caddr_t)p-&gt;end_page_ptr) + p-&gt;size;
        } else {
            p-&gt;end_page_ptr = 0;
        }
    }

    if (ret) {
        p-&gt;requested += size;
        MEMCACHED_SLABS_ALLOCATE(size, id, p-&gt;size, ret);
    } else {
        MEMCACHED_SLABS_ALLOCATE_FAILED(size, id);
    }

    return ret;
}
</code></pre>

<p>这个函数主要是将slab里面的chunk设置成free. 设置free不是把他归还给内存池
而是把这个item放入到这个slabclass的slots中</p>

<pre><code>static void do_slabs_free(void *ptr, const size_t size, unsigned int id) {
    slabclass_t *p;

    assert(((item *)ptr)-&gt;slabs_clsid == 0);
    assert(id &gt;= POWER_SMALLEST &amp;&amp; id &lt;= power_largest);
    if (id &lt; POWER_SMALLEST || id &gt; power_largest)
        return;

    MEMCACHED_SLABS_FREE(size, id, ptr);
    p = &amp;slabclass;[id];

    /*
        刚开始看这里的时候不明白,为什么slots数组需要malloc空间,
        因为slots是指针数组,这里malloc分配的内存空间是给这个指针数组的.
        然后这个数组每一个都指向在slab里面被free的chunk.
    */
    if (p-&gt;sl_curr == p-&gt;sl_total) { /* need more space on the free list */
        int new_size = (p-&gt;sl_total != 0) ? p-&gt;sl_total * 2 : 16;  /* 16 is arbitrary */
        void **new_slots = realloc(p-&gt;slots, new_size * sizeof(void *));
        //这里是给slots数组malloc了这么多数量的void指针.
        if (new_slots == 0)
            return;
        p-&gt;slots = new_slots;
        p-&gt;sl_total = new_size;
    }
    p-&gt;slots[p-&gt;sl_curr++] = ptr; //这里把sl_curr指向了这个ptr,这个ptr就是一个slab里面的一个空&gt;闲的chunk处.所以这里空闲数组又获得了一个空间,这里sl_curr可用的slots数+1.
    p-&gt;requested -= size;
    return;
}
</code></pre>

</section>
<section class="meta">
<span class="author">
  <a href="http://baotiao.github.io/">陈宗志</a>
</span>
<span class="time">
  /
  <time datetime="2012-02-18">2012-02-18</time>
</span>
<br />
<span class="license">
  Published under <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">(CC) BY-NC-SA</a>
</span>

<span class="categories">
  in categories
  
  <a href="http://baotiao.github.io/categories/#tech" title="tech">tech</a>&nbsp;
  
</span>


<span class="tags">
  tagged with 
  
  <a href="http://baotiao.github.io/tags/#memcache" title="memcache">memcache</a>&nbsp;
  
</span>

</section>

<div class="bshare-custom"><a title="åäº«å°æ°æµªå¾®å" class="bshare-sinaminiblog"></a><a title="åäº«å°Facebook" class="bshare-facebook"></a><a title="åäº«å°Twitter" class="bshare-twitter"></a><a title="æ´å¤å¹³å°" class="bshare-more bshare-more-icon more-style-addthis"></a></div><script type="text/javascript" charset="utf-8" src="http://static.bshare.cn/b/buttonLite.js#style=-1&amp;uuid=17304268-f570-4255-9088-f5132e6fd01b&amp;pophcol=1&amp;lang=zh"></script><script type="text/javascript" charset="utf-8" src="http://static.bshare.cn/b/bshareC0.js"></script>
<section class="comment">
<div id="disqus_thread"></div>
<script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'baotiao'; // required: replace example with your forum shortname
		var disqus_rul = 'http://baotiao.github.io/2012/02/memcache-slabs/';

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
</section>

<script type="text/javascript">
$(function(){
  $(document).keydown(function(e) {
    if (e.target.nodeName.toUpperCase() != 'BODY') return;
    var url = false;
        if (e.which == 37 || e.which == 74) {  // Left arrow and J
            
        url = 'http://baotiao.github.io/2012/02/event-like-memcache/';
        
        }
        else if (e.which == 39 || e.which == 75) {  // Right arrow and K
            
        url = 'http://baotiao.github.io/2012/03/memcached-meituan/';
        
        }
        if (url) {
            window.location = url;
        }
  });
})
</script>



        </article>

	<div id="message"><a href="#top">Scroll to top</a></div>
	</div>
</div>

<script type="text/javascript" src="/media/js/jquery-1.7.1.min.js"></script>
<script type="text/javascript" src="/media/js/code/prettify.js"></script>

 <script type="text/javascript">
      $(function(){
        $("pre").addClass("prettyprint");
        prettyPrint();
        $('.entry a').each(function(){
          if($(this).attr("href").indexOf("chenzongzhi") == -1){
            $(this).attr("target", "_blank");
          }
        })
      });
</script>


<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-35023741-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>



<script type="text/javascript">
$(function () {

    /* set variables locally for increased performance */
    var scroll_timer;
    var displayed = false;
    var $message = $('#message a');
    var $window = $(window);
    var top = $(document.body).children(0).position().top;

    /* react to scroll event on window */
    $window.scroll(function () {
        window.clearTimeout(scroll_timer);
        scroll_timer = window.setTimeout(function () {
            if($window.scrollTop() <= top + 800)
            {
                displayed = false;
                $message.fadeOut(1000);
            }
            else if(displayed == false)
            {
                displayed = true;
                $message.stop(true, true).show().click(function () { $message.fadeOut(1000); });
            }
        }, 100);
    });
});
</script>
  </body>
</html>
