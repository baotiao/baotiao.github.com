<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>cpu cache tutorial &#8211; baotiao</title>
    <link rel="dns-prefetch" href="//maxcdn.bootstrapcdn.com">
    <link rel="dns-prefetch" href="//cdn.mathjax.org">
    <link rel="dns-prefetch" href="//cdnjs.cloudflare.com">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="cpu cache tutorial">
    <meta name="robots" content="all">
    <meta name="author" content="baotiao">
    <meta name="keywords" content="">
    <link rel="canonical" href="http://localhost:4000/2018/02/06/cpu-cacheline/">
    <link rel="alternate" type="application/rss+xml" title="RSS Feed for baotiao" href="/feed.xml" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/pixyll.css?202204240519" type="text/css">

    <!-- Fonts -->
    
    <link href='//fonts.googleapis.com/css?family=Merriweather:900,900italic,300,300italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Lato:900,300' rel='stylesheet' type='text/css'>
    
    

    <!-- MathJax -->
    

    <!-- Verifications -->
    
    

    <!-- Open Graph -->
    <!-- From: https://github.com/mmistakes/hpstr-jekyll-theme/blob/master/_includes/head.html -->
    <meta property="og:locale" content="en_US">
    <meta property="og:type" content="article">
    <meta property="og:title" content="cpu cache tutorial">
    <meta property="og:description" content="做有积累的事情">
    <meta property="og:url" content="http://localhost:4000/2018/02/06/cpu-cacheline/">
    <meta property="og:site_name" content="baotiao">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary" />
    
        <meta name="twitter:site" content="@baotiao" />
    
    <meta name="twitter:title" content="cpu cache tutorial" />
    <meta name="twitter:description" content="cpu cache tutorial" />
    <meta name="twitter:url" content="http://localhost:4000/2018/02/06/cpu-cacheline/" />

    <!-- Icons -->
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
    <link rel="icon" type="image/png" href="/favicon-192x192.png" sizes="192x192">
    <link rel="icon" type="image/png" href="/favicon-160x160.png" sizes="160x160">
    <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
    <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
    <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">

    
</head>

<body class="site">
  
	

  <div class="site-wrap">
    <header class="site-header px2 px-responsive">
  <div class="mt2 wrap">
    <div class="measure">
      <a href="http://localhost:4000" class="site-title">baotiao</a>
      <nav class="site-nav">
        
    

    
        <a href="/about/">About</a>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    


    

    

    

    

    
        <a href="/links/">Links</a>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    


    

    

    

    

    

    
        <a href="/paper/">Paper</a>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    


      </nav>
      <div class="clearfix"></div>
      
    </div>
  </div>
</header>


    <div class="post p2 p-responsive wrap" role="main">
      <div class="measure">
        


<div class="post-header mb2">
  <h1>cpu cache tutorial</h1>
  <span class="post-meta">Feb 6 2018</span><br>
  
  <span class="post-meta small">
  
    2 minute read
  
  </span>
</div>

<article class="post-content">
  <h3 id="cpu-cache">cpu cache</h3>

<p>reference:</p>

<p>http://cenalulu.github.io/linux/all-about-cpu-cache/</p>

<p>http://igoro.com/archive/gallery-of-processor-cache-effects/</p>

<p>一般来说x86 结构cpu cache line 的大小是64byte, arm cacheline 是32byte</p>

<p>Cache Line可以简单的理解为CPU Cache中的最小缓存单位。目前主流的CPU Cache的Cache Line大小都是64Bytes。假设我们有一个512字节的一级缓存，那么按照64B的缓存单位大小来算，这个一级缓存所能存放的缓存个数就是<code class="language-plaintext highlighter-rouge">512/64 = 8</code>个。</p>

<p>cpu 的cache line 会有很多, 然后不同的 cache line 组成一个set, 也就是说同一个set 里面的多个cache line, 如果一个set 有8个cache line, 那么这个set 能够缓存的数据就是512 byte</p>

<p>所以cache coherence 指得就是由于 cpu 从内存中获取数据的时候, 一般都是64byte 的方式获取, 会提前prefetch, 那么比较好的做法是让cpu 顺序访问内存, 这样就可以充分利用到cpu prefetch 的特性, 如果是随机访问的话, 就无法利用这个特性了</p>

<p><strong>那么我们写代码的时候如何更好的使用cache line 呢?</strong></p>

<ol>
  <li>
    <p>尽可能的顺序访问内存, 不要随机访问内存. 因为一个cache line 的大小是64btye, 如果访问的内存不连续, 那么就浪费了这个prefetch 的内容, 同样对于写入也是如此, 顺序写入, 可以批量提交给cache, 能够最大限度利用总线带宽.</p>
  </li>
  <li>
    <p>在组织一个struct 的时候, 尽可能将有可能被一起访问, 因为这样能够保证cpu 从内存读取数据的时候都在一个 cache line 里面, 并且cpu 默认会进行预取</p>
  </li>
  <li>
    <p>做好一个struct 内部的padding,  也就是尽可能按照64 bytes 做padding, 这样可以避免的问题是一个struct 在64 btyes 之内的不同的变量如果被多个cpu 获得, 也可能跨cache line, 那么在修改其中一个的时候, 需要把另外一个invalidate 掉才行.  特别是多核的场景, 这个问题就很明显.</p>

    <p>但是这里也有一个折衷, 就是我们设计struct 的结构体应该是尽可能的紧凑, 这样才能更有效的利用cpu cache line. 但是这里增加了padding 以后, 这个struct 就不紧凑了, 那么怎么权衡呢?</p>

    <p>在读多写少的场景中, 是不用在意 cache 冲突, 更在意的是内存的紧凑, 或者是局部性. 因为很少发生多个核修改同一个变量的场景, 通过padding 的设计反而需要cpu 进行两次读取.</p>

    <p>但是在写多读少的场景中,  就更多的需要注意padding, 因为多核场景大量的写入很容易导致cache invalidate, 因此需要更注重padding</p>

    <p>当然具体的如何设计struct 还是需要通过具体的benchmark 来统计.</p>

    <p>典型的代码dpdk 中 rte_ring struct 的设计比如:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">rte_ring</span> <span class="p">{</span>
	<span class="cm">/*
	 * Note: this field kept the RTE_MEMZONE_NAMESIZE size due to ABI
	 * compatibility requirements, it could be changed to RTE_RING_NAMESIZE
	 * next time the ABI changes
	 */</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">RTE_MEMZONE_NAMESIZE</span><span class="p">]</span> <span class="n">__rte_cache_aligned</span><span class="p">;</span> <span class="cm">/**&lt; Name of the ring. */</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>               <span class="cm">/**&lt; Flags supplied at creation. */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">rte_memzone</span> <span class="o">*</span><span class="n">memzone</span><span class="p">;</span>
			<span class="cm">/**&lt; Memzone, if any, containing the rte_ring */</span>
	<span class="kt">uint32_t</span> <span class="n">size</span><span class="p">;</span>           <span class="cm">/**&lt; Size of ring. */</span>
	<span class="kt">uint32_t</span> <span class="n">mask</span><span class="p">;</span>           <span class="cm">/**&lt; Mask (size-1) of ring. */</span>
	<span class="kt">uint32_t</span> <span class="n">capacity</span><span class="p">;</span>       <span class="cm">/**&lt; Usable size of ring */</span>

	<span class="cm">/** Ring producer status. */</span>
	<span class="k">struct</span> <span class="n">rte_ring_headtail</span> <span class="n">prod</span> <span class="n">__rte_aligned</span><span class="p">(</span><span class="n">PROD_ALIGN</span><span class="p">);</span>

	<span class="cm">/** Ring consumer status. */</span>
	<span class="k">struct</span> <span class="n">rte_ring_headtail</span> <span class="n">cons</span> <span class="n">__rte_aligned</span><span class="p">(</span><span class="n">CONS_ALIGN</span><span class="p">);</span>
<span class="p">};</span>

</code></pre></div>    </div>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Open file table structure
 */</span>
<span class="k">struct</span> <span class="n">files_struct</span> <span class="p">{</span>
  <span class="cm">/*
   * read mostly part
   */</span>
	<span class="n">atomic_t</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fdtable</span> <span class="o">*</span><span class="n">fdt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fdtable</span> <span class="n">fdtab</span><span class="p">;</span>
  <span class="cm">/*
   * written part on a separate cache line in SMP
   */</span>
	<span class="n">spinlock_t</span> <span class="n">file_lock</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">next_fd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">embedded_fd_set</span> <span class="n">close_on_exec_init</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">embedded_fd_set</span> <span class="n">open_fds_init</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">fd_array</span><span class="p">[</span><span class="n">NR_OPEN_DEFAULT</span><span class="p">];</span>
<span class="p">};</span>

</code></pre></div>    </div>

    <p>这里也是把常读的部分和写的部分分开,  来让这部分的数据在不同的cache line 中的目的</p>
  </li>
  <li>
    <p>尽可能的只让一个cpu 去访问某一个变量的内存, 这样cache line 被失效的情况就少很多, 代码里面尽可能减少全局变量</p>
  </li>
  <li>
    <p>类似于cpu 的体系结构那样, 做batch, pipeline.</p>
  </li>
</ol>

<p>http://www.lighterra.com/papers/modernmicroprocessors/</p>

<p>比如内核代码里面也有这样的代码</p>

<h4 id="那么在我们做存储相关的项目中-关注cpu-cache-带来的收益大么">那么在我们做存储相关的项目中, 关注cpu cache 带来的收益大么?</h4>

<p>从延迟上考虑, 其实是不大.</p>

<p>写的好的对cpu cache 较为友好的代码, 而不关注cpu cache 友好的代码可能只有性能一倍差距(数据非自测), 但是对于存储服务来说, 通常的瓶颈要么在网卡, 要么是在磁盘上, cpu 是整个路径中非常小的一部分.</p>

<p>那么对于内存访问优化cpu cache 有意义么?</p>

<p><img src="https://i.imgur.com/CKWdOb1.png" alt="Imgur" /></p>

<p>比如从这种图中可以看到, 即使是l2 cache : main memory 也差不多是 1:10. 也就是说如果对于某一次访问 l2 cache 时间是 10ns, 然后内存访问的时间是100ns, 在没有优化前总的访问时间是 10 + 100 = 110ns, 在优化后访问的时间是 10/2 + 100 = 105 ns. 看起来对于延迟其实没有多大的提升. 只有5% 的性能优化.</p>

<p>这么说其实对于优化cpu cache 确实意义不大了?</p>

<p>其实还有一个维度我们没有考虑了, 那就是 cpu 的利用率.</p>

<p>我们只考虑了延迟, 但是我们没有考虑的是如果cpu 从内存中访问数据的时候, 其实cpu 是hang住的,  也就是说会加大了 cpu 的利用率, 其实无形中也会影响cpu 对其他指令的执行. 也就是说如果在cpu 无压力的场景, 那么其实对 cpu cache 友好的代码差不多在内存访问上能带来5% 的性能提升, 但是在cpu 利用率比较大的场景中, 如果代码对 cpu cache 不友好, 那么会导致cpu 流水线中, 所有的指令都慢下来, 进一步的加大对cpu 的压力.</p>

<p>最后感谢 @望澜 同学的指点, 望澜对cpu 这块真的非常在行</p>

</article>






  <div id="disqus_thread"></div>
  <script type="text/javascript">
    var disqus_shortname  = 'baotiao';
    var disqus_identifier = '/2018/02/06/cpu-cacheline';
    var disqus_title      = 'cpu cache tutorial';

    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>






      </div>
    </div>
  </div>

  <footer class="center">
</footer>


</body>
</html>
