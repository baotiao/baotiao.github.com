<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="author" content="陈宗志" />
	<title>levelDB Compaction 相关 | 陈宗志</title>
    <link rel="shortcut icon" href="/favicon.ico">
    <link href="http://baotiao.github.io/feed/" rel="alternate" title="陈宗志" type="application/atom+xml" />
    <link rel="stylesheet" href="/media/css/style.css">
    <link rel="stylesheet" href="/media/js/code/prettify.css">|
  </head>

	<div id="top"></div>
  <body>
    <div id="container">
      <div id="main" role="main">
        <header>
        <h1>levelDB Compaction 相关</h1>
        </header>

        <nav>
        <span><a title="home page" class="" href="http://baotiao.github.io/">home</a></span>
        <span><a title="about" class="" href="http://baotiao.github.io/about/">about</a></span>
        <span><a title="publication" class="" href="http://baotiao.github.io/publication/">publication</a></span>
        <span><a title="guestbook" class="" href="http://baotiao.github.io/guestbook/">guestbook</a></span>
        <span><a title="vitae" class="" href="http://baotiao.github.io/vitae/">vitae</a></span>
        <span><a title="categories" class="" href="http://baotiao.github.io/categories/">categories</a></span>
        <span><a title="tags" class="" href="http://baotiao.github.io/tags/">tags</a></span>
        <span><a title="links" class="" href="http://baotiao.github.io/links/">links</a></span>
        </nav>

        <article class="content">


        <section class="post">
<h1>levelDB</h1>

<h2>level DB 如何选择要Compaction的级别</h2>

<p>这个计算级别的函数在version_set::Finalize() 里面</p>

<p>在Finalize里面, 有一个算score的过程</p>

<p>看了一下这个 算Finalive的过程, 根据官方配置</p>

<pre><code>level 0: 差不多 4 个 sst 文件的时候分数 = 1
level 1: 差不多 5 个 sst 文件的时候分数 = 1
level 2: 差不多 50 个 sst 文件的时候分数 = 1
level 3: 差不多 500 个 sst 文件的时候分数 = 1
……
</code></pre>

<p>Finalize 只会在 LogAndApply 和 VersionSet::Recover() 的时候被调用, 也就是生成一个新的Version 的时候被调用.</p>

<p>结论: 所以可以这么说 每次生成一个新的Version 的时候 我们都已经初始化好了这个分数, 判断这一个version 是否需要 compaction 以及那个级别需要compaction</p>

<h2>level DB 会触发Compaction的操作</h2>

<p>触发这个MaybeScheduleCompaction() 的地方应该就是有可能触发后台这个Compaction的地方了, 目前会调用到这个MaybeScheduleCompaction() 的地方有</p>

<ul>
<li>在进行了一次Compaction 以后, 也就是在DBImpl::Background()函数里面</li>
</ul>


<p>为什么要做Compaction 因为可能会产生太多的新文件在新的一个级别, 所以会检查一下是否需要再进行一次Compaction</p>

<ul>
<li>在进行了一次 DBImpl::Get 操作了以后, 如果这个数据是在sst的文件里面找到的.
get的时候找到的这个key存在多个level 0 的文件里面那么就会触发compaction</li>
</ul>


<p>为什么要做Compaction 因为如果一个key在多个文件里面找到,那么说明这个key在多个level 0的文件里面重复了, 所以检查一下是否需要进行compaction
    if (have_stat_update &amp;&amp; current->UpdateStats(stats)) { // 这里如果有更新, 那么会判断是否启动后台的Compaction() 进程</p>

<ul>
<li>在 DBImpl::Write 的 MakeRoomForWrite 函数里面, 当immutable 生成一个level 0 文件的时候, 会检查一下是否需要Compaction, 这样会防止level 0 文件过多.</li>
</ul>


<p>为什么要做Compaction 这时候做Compaction, 主要为了防止不断的从immutable 生成到level 0 文件, 一直触发immutable到level0 过程, 而没有时间进行其他级别的合并 并且在MakeRoomFroWrite 的时候, 我们会检查一下 如果level0 的文件数 > config::kL0_SlowdownWritesTrigger 这个数据的大小的话. 那么我们 就会sleep 一段时间, 也是为了让出时间给其他级别进行Compaction</p>

<ul>
<li>在DB::Open() 这里函数里面, 如果Recover 成功以后, 并且进行了
s = impl->versions<em>>LogAndApply(&amp;edit, &amp;impl>mutex</em>);</li>
</ul>


<p>为什么要做Compaction 这里会将可以上次DB关闭以后没有来得及写入的数据重新回放, 所以这里可能会生成新的level 0的文件, 所以这里也会进行 检查 MaybeScheduleCompaction().</p>

<h2>具体的MaybeCompaction() 过程</h2>

<h4>函数入口</h4>

<pre><code>void DBImpl::MaybeScheduleCompaction() {
mutex_.AssertHeld();
// 如果后台有Compaction 线程, 那么直接退出
if (bg_compaction_scheduled_) {
            // Already scheduled
            // 如果db 要被 shut_down, 直接退出
        } else if (shutting_down_.Acquire_Load()) {
            // DB is being deleted; no more background compactions
            // 如果 imm_ 这个文件还是空的, 并且是manual_compaction是空的, 这里
            // TODO
        } else if (imm\_ == NULL &amp;&amp;
manual_compaction\_ == NULL &amp;&amp;
\!versions_-&gt;NeedsCompaction()) {
            // No work to be done
        } else {
            // 设置这个后台有compaction 线程已经启动
            bg_compaction_scheduled_ = true;
            env_-&gt;Schedule(&amp;DBImpl::BGWork, this); //调用下面的 BGWork函数. 这里虽然是env_, 当时这env_里面会调用这个函数指针, 调用DBImpl::BGWork 这个函数
        }
}

* 在PosixEnv::Schedule 这个函数里面

void PosixEnv::Schedule(void (*function)(void*), void\* arg) {
PthreadCall("lock", pthread_mutex_lock(&amp;mu_));

// Start background thread if necessary
// 看是否有后台线程已经启动, 如果没有启动就启动这个后台线程, 并执行一个死循环
// 具体的执行是BGThreadWrapper \-&gt; BGThread 这个函数,
// 在BGThread 函数就是一个死循环, 不断的从这个queue\_ 里面读出, 这个是FIFO的形式
// 读出, 先进先出. 没有做一个优先级的概念.
if (\!started_bgthread_) {
                started_bgthread_ = true;
                PthreadCall(
                        "create thread",
                        pthread_create(&amp;bgthread_, NULL,  &amp;PosixEnv::BGThreadWrapper, this));
            }

// If the queue is currently empty, the background thread may currently be
// waiting.
// 如果这个queue\_ 里面的数据当前是空的, 则等待cond 锁让它起来
if (queue_.empty()) {
                PthreadCall("signal", pthread_cond_signal(&amp;bgsignal_));
            }

// Add to priority queue
queue_.push_back(BGItem());
queue_.back().function = function; // 这里注册的函数是 &amp;DBImpl::BGWork
queue_.back().arg = arg; // 这里arg 是 db-&gt;this指针

PthreadCall("unlock", pthread_mutex_unlock(&amp;mu_));
}
</code></pre>

<h4>接下来是具体执行 函数 BackgroundCall() -> BackgroundCompaction().</h4>

<p>在BackgroundCompaction() 函数里面</p>

<p>优先 compaction immutable -> level0 sst</p>

<p>然后 我们都是!is_manual 的, 那么我们就要选择去Compaction() 那个级别的.</p>

<p>在versions_->PickCompaction().</p>

<p>这里我们有之前在Finalfize() 里面算出来的compaction_score_, 如果这个score &lt; 1 就不进行compaction.</p>

<p>这里可以看到并不是每次检查是否需要Compaction 的时候都会进行. 只有score >= 1 的时候levelDB才会选一个级别进行Compaction()</p>

<p>在选择好Compaction的级别以后. 就调用BackgroundCompaction</p>

<p>如果生成的这个Compaction 是空的, 那么就不进行Compaction
选择是否能直接将这个文件移动到level + 1, 而不用与level + 1 的文件进行归并的计算
进行真正的Compaction DoCompactionWork() 函数</p>

<h4>在DoCompactionWork()函数里面</h4>

<ul>
<li>对这些指针进行归并, 归并出一个MergeIterator input.</li>
</ul>


<p>具体的iterator 看leveldb iterator</p>

<ul>
<li>遍历获得的需要合并的数据, 如果这个key以前是否出现.</li>
</ul>


<p>如果已经出现过了就不会再进行处理 因为leveldb 里面对相同的key是进行过排序的. 默认squencenumber 最大的排在最前面, 也就是最新的数据排在最前面.</p>

<pre><code>如果这个key 的squenctNumber &lt; 当前快照的版本号, 说明这个key 是旧的了.
如果这个key 的类型是delete, 并且更高级别已经没有这个key的数据了, 那么这个key也会被drop掉
可以看出, levelDB 这里做了这些操作也都是尽可能的减少key的数量
</code></pre>

<ul>
<li>接下来就把这些剩余的key插入到新的version里面</li>
</ul>


</section>
<section class="meta">
<span class="author">
  <a href="http://mingxinglai.com/cn">陈宗志</a>
</span>
<span class="time">
  /
  <time datetime="2013-10-15">2013-10-15</time>
</span>
<br />
<span class="license">
  Published under <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">(CC) BY-NC-SA</a>
</span>

<span class="categories">
  in categories
  
  <a href="http://baotiao.github.io/categories/#tech" title="tech">tech</a>&nbsp;
  
</span>


<span class="tags">
  tagged with 
  
  <a href="http://baotiao.github.io/tags/#levelDB" title="levelDB">levelDB</a>&nbsp;
  
</span>

</section>

<div class="bshare-custom"><a title="åäº«å°æ°æµªå¾®å" class="bshare-sinaminiblog"></a><a title="åäº«å°Facebook" class="bshare-facebook"></a><a title="åäº«å°Twitter" class="bshare-twitter"></a><a title="æ´å¤å¹³å°" class="bshare-more bshare-more-icon more-style-addthis"></a></div><script type="text/javascript" charset="utf-8" src="http://static.bshare.cn/b/buttonLite.js#style=-1&amp;uuid=17304268-f570-4255-9088-f5132e6fd01b&amp;pophcol=1&amp;lang=zh"></script><script type="text/javascript" charset="utf-8" src="http://static.bshare.cn/b/bshareC0.js"></script>
<section class="comment">
<div id="disqus_thread"></div>
<script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'mingxing'; // required: replace example with your forum shortname
		var disqus_rul = 'http://baotiao.github.io/2013/10/leveldb-compaction/';

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>

<script type="text/javascript">
$(function(){
  $(document).keydown(function(e) {
    if (e.target.nodeName.toUpperCase() != 'BODY') return;
    var url = false;
        if (e.which == 37 || e.which == 74) {  // Left arrow and J
            
        url = 'http://baotiao.github.io/2013/09/leveldb-Get/';
        
        }
        else if (e.which == 39 || e.which == 75) {  // Right arrow and K
            
        }
        if (url) {
            window.location = url;
        }
  });
})
</script>



        </article>

	<div id="message"><a href="#top">Scroll to top</a></div>
	</div>
</div>

<script type="text/javascript" src="/media/js/jquery-1.7.1.min.js"></script>
<script type="text/javascript" src="/media/js/code/prettify.js"></script>

 <script type="text/javascript">
      $(function(){
        $("pre").addClass("prettyprint linenums");
        prettyPrint();
        $('.entry a').each(function(){
          if($(this).attr("href").indexOf("mingxinglai") == -1){
            $(this).attr("target", "_blank");
          }
        })
      });
</script>


<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-35023741-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>



<script type="text/javascript">
$(function () {

    /* set variables locally for increased performance */
    var scroll_timer;
    var displayed = false;
    var $message = $('#message a');
    var $window = $(window);
    var top = $(document.body).children(0).position().top;

    /* react to scroll event on window */
    $window.scroll(function () {
        window.clearTimeout(scroll_timer);
        scroll_timer = window.setTimeout(function () {
            if($window.scrollTop() <= top + 800)
            {
                displayed = false;
                $message.fadeOut(1000);
            }
            else if(displayed == false)
            {
                displayed = true;
                $message.stop(true, true).show().click(function () { $message.fadeOut(1000); });
            }
        }, 100);
    });
});
</script>
  </body>
</html>
