<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>使用systemtap 找内存泄露问题 &#8211; baotiao</title>
    <link rel="dns-prefetch" href="//maxcdn.bootstrapcdn.com">
    <link rel="dns-prefetch" href="//cdn.mathjax.org">
    <link rel="dns-prefetch" href="//cdnjs.cloudflare.com">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="使用systemtap 查找pika 内存泄露的问题">
    <meta name="robots" content="all">
    <meta name="author" content="baotiao">
    <meta name="keywords" content="">
    <link rel="canonical" href="http://localhost:4000/2017/06/14/systemtap-pika/">
    <link rel="alternate" type="application/rss+xml" title="RSS Feed for baotiao" href="/feed.xml" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/pixyll.css?202207041525" type="text/css">

    <!-- Fonts -->
    
    <link href='//fonts.googleapis.com/css?family=Merriweather:900,900italic,300,300italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Lato:900,300' rel='stylesheet' type='text/css'>
    
    

    <!-- MathJax -->
    

    <!-- Verifications -->
    
    

    <!-- Open Graph -->
    <!-- From: https://github.com/mmistakes/hpstr-jekyll-theme/blob/master/_includes/head.html -->
    <meta property="og:locale" content="en_US">
    <meta property="og:type" content="article">
    <meta property="og:title" content="使用systemtap 找内存泄露问题">
    <meta property="og:description" content="做有积累的事情">
    <meta property="og:url" content="http://localhost:4000/2017/06/14/systemtap-pika/">
    <meta property="og:site_name" content="baotiao">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary" />
    
        <meta name="twitter:site" content="@baotiao" />
    
    <meta name="twitter:title" content="使用systemtap 找内存泄露问题" />
    <meta name="twitter:description" content="使用systemtap 查找pika 内存泄露的问题" />
    <meta name="twitter:url" content="http://localhost:4000/2017/06/14/systemtap-pika/" />

    <!-- Icons -->
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
    <link rel="icon" type="image/png" href="/favicon-192x192.png" sizes="192x192">
    <link rel="icon" type="image/png" href="/favicon-160x160.png" sizes="160x160">
    <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
    <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
    <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">

    
</head>

<body class="site">
  
	

  <div class="site-wrap">
    <header class="site-header px2 px-responsive">
  <div class="mt2 wrap">
    <div class="measure">
      <a href="http://localhost:4000" class="site-title">baotiao</a>
      <nav class="site-nav">
        
    

    
        <a href="/about/">About</a>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    


    

    

    

    

    
        <a href="/links/">Links</a>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    


    

    

    

    

    

    
        <a href="/paper/">Paper</a>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    


      </nav>
      <div class="clearfix"></div>
      
    </div>
  </div>
</header>


    <div class="post p2 p-responsive wrap" role="main">
      <div class="measure">
        


<div class="post-header mb2">
  <h1>使用systemtap 找内存泄露问题</h1>
  <span class="post-meta">Jun 14 2017</span><br>
  
  <span class="post-meta small">
  
    2 minute read
  
  </span>
</div>

<article class="post-content">
  <p>前几周搞了好多天pika 内存泄露的问题, pika 在使用的过程中,在非正常关闭连接的情况下, 由于pika 网络编程框架Pink 在代码实现中没有正确处理, 导致非正常关闭的情况下, 只把这个句柄关闭, 而这个时候对应的连接指针依然是NULL, 导致这个连接的指针丢失, 导致了内存泄露.</p>

<p>程序的内存泄露是一个写c++程序常见的棘手的问题, 特别是在测试环境难以复现, 线上环境需要运行很长一段时间以后才可以出现的问题. 不稳定复现的bug 不是好bug</p>

<p>在排查这个问题的过程中, 发现systemtap 是一个好东西, 除了可以用来看内核的调用栈以外, 还可以用来观测用户空间的函数调用并进行统计,  并且systemtap 与valgrind 相比, 无需编译的时候加任何参数, 直接在线上就可以使用(当然了线上需要安装debuginfo debuginfo-common), 不需要业务的配合也可以观测</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/usr/bin/stap</span>

<span class="c"># 这里核心的想法就是通过systemtap 找到malloc, realloc 返回的地址, </span>
<span class="c"># 可以通过systemtap 里面的$return 来获得, 并记录, 然后再记录free 的时候是否对这些地址进行过free. </span>
<span class="c"># 可以通过 $ptr 来获得. 具体的systemtap 用法可以看官网</span>

probe begin
<span class="o">{</span>
  log<span class="o">(</span><span class="s2">"begin to probe</span><span class="se">\n</span><span class="s2">"</span><span class="o">)</span>
<span class="o">}</span>

<span class="c"># 对某一个地址调用的malloc, free的次数. </span>
<span class="c"># 如果 = 0, 说明正常free掉, </span>
<span class="c"># 如果 = 1, 说明malloc, 但是还没被free</span>
<span class="c"># 如果 &gt; 1, 说明这个地址被多次给malloc返回给用户, 肯定不正常</span>
<span class="c"># 如果 &lt; 1, 说明这个地址被多次free 也就是我们常说的double free 问题</span>
global g_cnt
<span class="c"># 用来记录前一次调用的时候的 ubacktrace 信息</span>
global g_stack
<span class="c"># 用来记录上次操作的时间</span>
global g_time

<span class="c"># 每一次malloc, realloc 最后都会调到glic 里面的__libc_malloc, __libc_calloc</span>
probe process<span class="o">(</span><span class="s2">"/usr/local/pika22/lib/libtcmalloc.so.4"</span><span class="o">)</span>.function<span class="o">(</span><span class="s2">"__libc_malloc"</span><span class="o">)</span>.return, process<span class="o">(</span><span class="s2">"/usr/local/pika22/lib/libtcmalloc.so.4"</span><span class="o">)</span>.function<span class="o">(</span><span class="s2">"__libc_calloc"</span><span class="o">)</span>.return

<span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span>tid<span class="o">()</span> <span class="o">==</span> 11808<span class="o">)</span> <span class="o">{</span>
			g_cnt[<span class="nv">$return</span><span class="o">]</span>++
			g_stack[<span class="nv">$return</span><span class="o">]</span> <span class="o">=</span> sprint_ubacktrace<span class="o">()</span>
			g_time[<span class="nv">$return</span><span class="o">]</span> <span class="o">=</span> gettimeofday_s<span class="o">()</span>
	<span class="o">}</span>
<span class="o">}</span>

probe process<span class="o">(</span><span class="s2">"/usr/local/pika22/lib/libtcmalloc.so.4"</span><span class="o">)</span>.function<span class="o">(</span><span class="s2">"__libc_free"</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span>tid<span class="o">()</span> <span class="o">==</span> 11808 <span class="o">&amp;&amp;</span> g_time[<span class="nv">$ptr</span><span class="o">]</span> <span class="o">!=</span> 0<span class="o">)</span> <span class="o">{</span>
    <span class="c"># 这里对于之前没有进行过处理的节点忽略</span>
    g_cnt[<span class="nv">$ptr</span><span class="o">]</span><span class="nt">--</span>
    <span class="c"># 正常的malloc free 分支</span>
		<span class="k">if</span> <span class="o">(</span>g_cnt[<span class="nv">$ptr</span><span class="o">]</span> <span class="o">==</span> 0<span class="o">)</span> <span class="o">{</span>
			<span class="k">if</span> <span class="o">(</span><span class="nv">$ptr</span> <span class="o">!=</span> 0<span class="o">)</span> <span class="o">{</span>
				<span class="nb">printf</span><span class="o">(</span><span class="s2">"A normal malloc and free</span><span class="se">\n</span><span class="s2">"</span><span class="o">)</span>
				g_stack[<span class="nv">$ptr</span><span class="o">]</span> <span class="o">=</span> sprint_ubacktrace<span class="o">()</span>
			<span class="o">}</span>
      <span class="c"># 可能出现的double free 分支</span>
		<span class="o">}</span> <span class="k">else if</span> <span class="o">(</span>g_cnt[<span class="nv">$ptr</span><span class="o">]</span> &lt; 0 <span class="o">&amp;&amp;</span> <span class="nv">$ptr</span> <span class="o">!=</span> 0<span class="o">)</span> <span class="o">{</span>
				<span class="nb">printf</span><span class="o">(</span><span class="s2">"double free problem address %d cnt %d</span><span class="se">\n</span><span class="s2">"</span>, <span class="nv">$ptr</span>, g_cnt[<span class="nv">$ptr</span><span class="o">])</span>
				<span class="nb">printf</span><span class="o">(</span><span class="s2">"%s</span><span class="se">\n</span><span class="s2">"</span>, g_stack[<span class="nv">$ptr</span><span class="o">])</span>
				<span class="nb">printf</span><span class="o">(</span><span class="s2">"the destructure </span><span class="se">\n</span><span class="s2">"</span><span class="o">)</span>
				print_ubacktrace<span class="o">()</span> 
      <span class="c"># 多次malloc 返回同一个地址的分支, 这种情况很少见</span>
		<span class="o">}</span> <span class="k">else if</span> <span class="o">(</span>g_cnt[<span class="nv">$ptr</span><span class="o">]</span> <span class="o">&gt;</span> 1 <span class="o">&amp;&amp;</span> <span class="nv">$ptr</span> <span class="o">!=</span> 0<span class="o">)</span> <span class="o">{</span>
			<span class="nb">printf</span><span class="o">(</span><span class="s2">"malloc large than 0</span><span class="se">\n</span><span class="s2">"</span><span class="o">)</span>
			print_ubacktrace<span class="o">()</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>

probe timer.s<span class="o">(</span>5<span class="o">)</span> <span class="o">{</span>
	foreach <span class="o">(</span>mem <span class="k">in </span>g_cnt<span class="o">)</span> <span class="o">{</span>
    <span class="c"># 这里可以根据定义来调整这个10 的大小, 也就是说这里想打印出 10s 之前申请过内存</span>
    <span class="c"># 但是 10s 之内没有被free 的情况, 这里因为 pika 在短连接的时候都是10之内申请 然后就释放</span>
    <span class="c"># 如果10s 之内没有释放, 那肯定就是内存出现了问题</span>
		<span class="k">if</span> <span class="o">(</span>g_cnt[mem] <span class="o">&gt;</span> 0 <span class="o">&amp;&amp;</span> gettimeofday_s<span class="o">()</span> - g_time[mem] <span class="o">&gt;</span> 10<span class="o">)</span> <span class="o">{</span>
			<span class="nb">printf</span><span class="o">(</span><span class="s2">"</span><span class="se">\n\n</span><span class="s2">%s</span><span class="se">\n\n</span><span class="s2">"</span>, g_stack[mem]<span class="o">)</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>可以看到有这样的输出结果:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>_ZN4pink9RedisConnC2EiRKSs+0x8d [pika]
_ZN14PikaClientConnC1EiSsPN4pink6ThreadE+0x11 [pika]
_ZN4pink12WorkerThreadI14PikaClientConnE10ThreadMainEv+0x33c [pika]
_ZN4pink6Thread9RunThreadEPv+0x9d [pika]
start_thread+0xd1 [libpthread-2.12.so]
__clone+0x6d [libc-2.12.so]



_ZN4pink9RedisConnC2EiRKSs+0x7c [pika]
_ZN14PikaClientConnC1EiSsPN4pink6ThreadE+0x11 [pika]
_ZN4pink12WorkerThreadI14PikaClientConnE10ThreadMainEv+0x33c [pika]
_ZN4pink6Thread9RunThreadEPv+0x9d [pika]
start_thread+0xd1 [libpthread-2.12.so]
__clone+0x6d [libc-2.12.so]



_ZN4pink9RedisConnC2EiRKSs+0x8d [pika]
_ZN14PikaClientConnC1EiSsPN4pink6ThreadE+0x11 [pika]
_ZN4pink12WorkerThreadI14PikaClientConnE10ThreadMainEv+0x33c [pika]
_ZN4pink6Thread9RunThreadEPv+0x9d [pika]
start_thread+0xd1 [libpthread-2.12.so]
__clone+0x6d [libc-2.12.so]
</code></pre></div></div>

<p>以上就是在这个stap 起来以后, 申请的内存在10s 内没有被正常free 的操作, 这样根据这个堆栈信息就可以知道是我们申请了RedisConn 以后, 并没有被释放导致的内存泄露, 具体看代码我们可以发现</p>

<p>具体代码如下:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		  <span class="c1">// 这里声明获得对应的连接的指针</span>
          <span class="n">in_conn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
          <span class="kt">int</span> <span class="n">should_close</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*&gt;::</span><span class="n">iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">conns_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">pfe</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="n">iter</span> <span class="o">=</span> <span class="n">conns_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">pfe</span><span class="o">-&gt;</span><span class="n">fd_</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">==</span> <span class="n">conns_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">pink_epoll_</span><span class="o">-&gt;</span><span class="n">PinkDelEvent</span><span class="p">(</span><span class="n">pfe</span><span class="o">-&gt;</span><span class="n">fd_</span><span class="p">);</span>
            <span class="k">continue</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">pfe</span><span class="o">-&gt;</span><span class="n">mask_</span> <span class="o">&amp;</span> <span class="n">EPOLLIN</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 如果有读事件, 则对这个连接进行赋值</span>
            <span class="n">in_conn</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Conn</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>
            <span class="p">...</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">pfe</span><span class="o">-&gt;</span><span class="n">mask_</span> <span class="o">&amp;</span> <span class="n">EPOLLOUT</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 如果有读事件, 则对这个连接进行赋值</span>
            <span class="n">in_conn</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Conn</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>
            <span class="p">...</span>
             
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">((</span><span class="n">pfe</span><span class="o">-&gt;</span><span class="n">mask_</span>  <span class="o">&amp;</span> <span class="n">EPOLLERR</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">pfe</span><span class="o">-&gt;</span><span class="n">mask_</span> <span class="o">&amp;</span> <span class="n">EPOLLHUP</span><span class="p">)</span> <span class="o">||</span> <span class="n">should_close</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">{</span>
            <span class="n">RWLock</span> <span class="n">l</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rwlock_</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
            <span class="n">pink_epoll_</span><span class="o">-&gt;</span><span class="n">PinkDelEvent</span><span class="p">(</span><span class="n">pfe</span><span class="o">-&gt;</span><span class="n">fd_</span><span class="p">);</span>
            <span class="c1">// 这里这两行关闭这个句柄, 并清空对应的连接</span>
            <span class="c1">// 由于如果没有接收到读或者写事件, 那么这里的in_conn 依然是NULL</span>
            <span class="c1">// 因此就造成了内存泄露</span>
            <span class="n">close</span><span class="p">(</span><span class="n">pfe</span><span class="o">-&gt;</span><span class="n">fd_</span><span class="p">);</span>
            <span class="k">delete</span><span class="p">(</span><span class="n">in_conn</span><span class="p">);</span>
            <span class="n">in_conn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

            <span class="n">conns_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">pfe</span><span class="o">-&gt;</span><span class="n">fd_</span><span class="p">);</span>
            <span class="p">}</span>
          <span class="p">}</span>
<span class="err"> </span>
</code></pre></div></div>

<p>从上面的代码注释中就可以看出内存泄露的原因了.  目前已经修改了Pika 的网络编程框架Pink.</p>

<p>修改后</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		   <span class="c1">// 这里声明获得对应的连接的指针</span>
          <span class="n">in_conn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
          <span class="kt">int</span> <span class="n">should_close</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*&gt;::</span><span class="n">iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">conns_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">pfe</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="n">iter</span> <span class="o">=</span> <span class="n">conns_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">pfe</span><span class="o">-&gt;</span><span class="n">fd_</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">==</span> <span class="n">conns_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">pink_epoll_</span><span class="o">-&gt;</span><span class="n">PinkDelEvent</span><span class="p">(</span><span class="n">pfe</span><span class="o">-&gt;</span><span class="n">fd_</span><span class="p">);</span>
            <span class="k">continue</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="c1">// 不论有什么事件到达, 先对对应的连接赋值</span>
          <span class="n">in_conn</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Conn</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">pfe</span><span class="o">-&gt;</span><span class="n">mask_</span> <span class="o">&amp;</span> <span class="n">EPOLLIN</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 那么这里就不需要赋值了</span>
            <span class="p">...</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">pfe</span><span class="o">-&gt;</span><span class="n">mask_</span> <span class="o">&amp;</span> <span class="n">EPOLLOUT</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 那么这里就不需要赋值了</span>
            <span class="p">...</span>
          <span class="p">}</span>
</code></pre></div></div>

<p>不过上面依然有困惑我们的地方在于, 无论是调用close() 关闭连接, 还是通过Kill 强行杀死进程, 都会产生读事件, 因此对应的in_conn 能够赋值, 也就能够正常释放了. 可是出现问题的时候关闭一个连接并没有读事件产生. 后续再看看吧</p>

</article>






  <div id="disqus_thread"></div>
  <script type="text/javascript">
    var disqus_shortname  = 'baotiao';
    var disqus_identifier = '/2017/06/14/systemtap-pika';
    var disqus_title      = '使用systemtap 找内存泄露问题';

    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>






      </div>
    </div>
  </div>

  <footer class="center">
</footer>


</body>
</html>
