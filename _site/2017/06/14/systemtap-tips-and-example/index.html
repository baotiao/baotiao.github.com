<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>systemtap tips and examples &#8211; baotiao</title>
    <link rel="dns-prefetch" href="//maxcdn.bootstrapcdn.com">
    <link rel="dns-prefetch" href="//cdn.mathjax.org">
    <link rel="dns-prefetch" href="//cdnjs.cloudflare.com">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="systemtap tips and examples">
    <meta name="robots" content="all">
    <meta name="author" content="baotiao">
    <meta name="keywords" content="">
    <link rel="canonical" href="http://localhost:4000/2017/06/14/systemtap-tips-and-example/">
    <link rel="alternate" type="application/rss+xml" title="RSS Feed for baotiao" href="/feed.xml" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/pixyll.css?202204110307" type="text/css">

    <!-- Fonts -->
    
    <link href='//fonts.googleapis.com/css?family=Merriweather:900,900italic,300,300italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Lato:900,300' rel='stylesheet' type='text/css'>
    
    

    <!-- MathJax -->
    

    <!-- Verifications -->
    
    

    <!-- Open Graph -->
    <!-- From: https://github.com/mmistakes/hpstr-jekyll-theme/blob/master/_includes/head.html -->
    <meta property="og:locale" content="en_US">
    <meta property="og:type" content="article">
    <meta property="og:title" content="systemtap tips and examples">
    <meta property="og:description" content="做有积累的事情">
    <meta property="og:url" content="http://localhost:4000/2017/06/14/systemtap-tips-and-example/">
    <meta property="og:site_name" content="baotiao">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary" />
    
        <meta name="twitter:site" content="@baotiao" />
    
    <meta name="twitter:title" content="systemtap tips and examples" />
    <meta name="twitter:description" content="systemtap tips and examples" />
    <meta name="twitter:url" content="http://localhost:4000/2017/06/14/systemtap-tips-and-example/" />

    <!-- Icons -->
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
    <link rel="icon" type="image/png" href="/favicon-192x192.png" sizes="192x192">
    <link rel="icon" type="image/png" href="/favicon-160x160.png" sizes="160x160">
    <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
    <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
    <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">

    
</head>

<body class="site">
  
	

  <div class="site-wrap">
    <header class="site-header px2 px-responsive">
  <div class="mt2 wrap">
    <div class="measure">
      <a href="http://localhost:4000" class="site-title">baotiao</a>
      <nav class="site-nav">
        
    

    
        <a href="/about/">About</a>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    


    

    

    

    

    
        <a href="/links/">Links</a>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    


    

    

    

    

    

    
        <a href="/paper/">Paper</a>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    


      </nav>
      <div class="clearfix"></div>
      
    </div>
  </div>
</header>


    <div class="post p2 p-responsive wrap" role="main">
      <div class="measure">
        


<div class="post-header mb2">
  <h1>systemtap tips and examples</h1>
  <span class="post-meta">Jun 14 2017</span><br>
  
  <span class="post-meta small">
  
    6 minute read
  
  </span>
</div>

<article class="post-content">
  <h3 id="systemtap-tips-and-example">systemtap tips and example</h3>

<p>man stapprobes 可以看到大部分的文档信息</p>

<h4 id="stap-常用参数">stap 常用参数:</h4>

<p>-c: 通过指定 -c 参数可以在运行stap 程序的时候通过target() 获得当前的pid() 写起来很方便</p>

<p>stap m.stp -c ./a.out</p>

<p>那么程序里面就可以这么写</p>

<p><code class="language-plaintext highlighter-rouge">if</code> (target()== pid()) {</p>

<p>-x: 和 -c 一样可以再 target() 里面获得pid</p>

<p>-d: 增加某一个库的或者二进制文件</p>

<p>sudo stap tm.stp  -d /lib64/libc-2.12.so -d /usr/local/pika22/bin/pika</p>

<p>可以通过stap -l 看到不管是用户空间还是内核里面的某一个函数所在的路径. 换成 -L 可以看到具体可以看的变量</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>xusiliang@redis220 ~]<span class="nv">$ </span>stap <span class="nt">-l</span> <span class="s1">'process("/usr/local/pika22/bin/pika").function("AutoPurge")'</span>
process<span class="o">(</span><span class="s2">"/usr/local/pika22/bin/pika"</span><span class="o">)</span>.function<span class="o">(</span><span class="s2">"AutoPurge@src/pika_server.cc:1164"</span><span class="o">)</span>

<span class="o">[</span>xusiliang@redis220 ~]<span class="nv">$ </span>stap <span class="nt">-L</span> <span class="s1">'process("/usr/local/pika22/bin/pika").function("AutoPurge")'</span>
process<span class="o">(</span><span class="s2">"/usr/local/pika22/bin/pika"</span><span class="o">)</span>.function<span class="o">(</span><span class="s2">"AutoPurge@src/pika_server.cc:1164"</span><span class="o">)</span> <span class="nv">$this</span>:class PikaServer<span class="k">*</span> const

<span class="c"># 还可以使用正则, 看到所有的函数</span>
<span class="o">[</span>xusiliang@redis220 ~]<span class="nv">$ </span>stap <span class="nt">-L</span> <span class="s1">'process("/usr/local/pika22/bin/pika").function("Auto*")'</span>
process<span class="o">(</span><span class="s2">"/usr/local/pika22/bin/pika"</span><span class="o">)</span>.function<span class="o">(</span><span class="s2">"AutoCompactRange@src/pika_server.cc:1114"</span><span class="o">)</span> <span class="nv">$this</span>:class PikaServer<span class="k">*</span> const
process<span class="o">(</span><span class="s2">"/usr/local/pika22/bin/pika"</span><span class="o">)</span>.function<span class="o">(</span><span class="s2">"AutoPurge@src/pika_server.cc:1164"</span><span class="o">)</span> <span class="nv">$this</span>:class PikaServer<span class="k">*</span> const
process<span class="o">(</span><span class="s2">"/usr/local/pika22/bin/pika"</span><span class="o">)</span>.function<span class="o">(</span><span class="s2">"AutoRollLogger@./db/auto_roll_logger.h:24"</span><span class="o">)</span>
process<span class="o">(</span><span class="s2">"/usr/local/pika22/bin/pika"</span><span class="o">)</span>.function<span class="o">(</span><span class="s2">"AutoThreadOperationStageUpdater@util/thread_status_util.cc:161"</span><span class="o">)</span> <span class="nv">$this</span>:class AutoThreadOperationStageUpdater<span class="k">*</span> const <span class="nv">$stage</span>:enum OperationStage

<span class="c"># 想使用statement probe 的时候, 很多时候某些行是有问题的, 这个时候只能通过 -L 可以看出到底哪些行可以probe, 这里就是在fork.c 里面这个copy_process 可以加statement 的地方</span>
└─[<span class="nv">$]</span> <span class="nb">sudo </span>stap <span class="nt">-L</span> <span class="s1">'kernel.statement("copy_process@fork.c:*")'</span>
kernel.statement<span class="o">(</span><span class="s2">"copy_process@kernel/fork.c:1148"</span><span class="o">)</span> <span class="nv">$clone_flags</span>:long unsigned int <span class="nv">$stack_start</span>:long unsigned int <span class="nv">$stack_size</span>:long unsigned int <span class="nv">$child_tidptr</span>:int<span class="k">*</span> <span class="nv">$pid</span>:struct pid<span class="k">*</span> <span class="nv">$trace</span>:int
kernel.statement<span class="o">(</span><span class="s2">"copy_process@kernel/fork.c:1158"</span><span class="o">)</span> <span class="nv">$trace</span>:int <span class="nv">$pid</span>:struct pid<span class="k">*</span> <span class="nv">$child_tidptr</span>:int<span class="k">*</span> <span class="nv">$stack_size</span>:long unsigned int <span class="nv">$stack_start</span>:long unsigned int <span class="nv">$clone_flags</span>:long unsigned int
kernel.statement<span class="o">(</span><span class="s2">"copy_process@kernel/fork.c:1161"</span><span class="o">)</span> <span class="nv">$trace</span>:int <span class="nv">$pid</span>:struct pid<span class="k">*</span> <span class="nv">$child_tidptr</span>:int<span class="k">*</span> <span class="nv">$stack_size</span>:long unsigned int <span class="nv">$stack_start</span>:long unsigned int <span class="nv">$clone_flags</span>:long unsigned int
kernel.statement<span class="o">(</span><span class="s2">"copy_process@kernel/fork.c:1168"</span><span class="o">)</span> <span class="nv">$trace</span>:int <span class="nv">$pid</span>:struct pid<span class="k">*</span> <span class="nv">$child_tidptr</span>:int<span class="k">*</span> <span class="nv">$stack_size</span>:long unsigned int <span class="nv">$stack_start</span>:long unsigned int <span class="nv">$clone_flags</span>:long unsigned int
kernel.statement<span class="o">(</span><span class="s2">"copy_process@kernel/fork.c:1176"</span><span class="o">)</span> <span class="nv">$trace</span>:int <span class="nv">$pid</span>:struct pid<span class="k">*</span> <span class="nv">$child_tidptr</span>:int<span class="k">*</span> <span class="nv">$stack_size</span>:long unsigned int <span class="nv">$stack_start</span>:long unsigned int <span class="nv">$clone_flags</span>:long unsigned int

<span class="c"># 这里是找出sys_madvise 可以加statement 的行数有哪些, 并且可以看打印哪些变量</span>
└─[<span class="nv">$]</span> <span class="nb">sudo </span>stap <span class="nt">-L</span> <span class="s1">'kernel.statement("sys_madvise@madvise.c:*")'</span>
kernel.statement<span class="o">(</span><span class="s2">"SyS_madvise@mm/madvise.c:460"</span><span class="o">)</span> <span class="nv">$start</span>:long int <span class="nv">$len_in</span>:long int <span class="nv">$behavior</span>:long int
kernel.statement<span class="o">(</span><span class="s2">"SyS_madvise@mm/madvise.c:464"</span><span class="o">)</span> <span class="nv">$start</span>:long int <span class="nv">$len_in</span>:long int <span class="nv">$behavior</span>:long int
kernel.statement<span class="o">(</span><span class="s2">"SyS_madvise@mm/madvise.c:471"</span><span class="o">)</span> <span class="nv">$start</span>:long int <span class="nv">$len_in</span>:long int <span class="nv">$behavior</span>:long int
kernel.statement<span class="o">(</span><span class="s2">"SyS_madvise@mm/madvise.c:472"</span><span class="o">)</span> <span class="nv">$start</span>:long int <span class="nv">$len_in</span>:long int <span class="nv">$behavior</span>:long int
kernel.statement<span class="o">(</span><span class="s2">"SyS_madvise@mm/madvise.c:475"</span><span class="o">)</span> <span class="nv">$start</span>:long int <span class="nv">$len_in</span>:long int <span class="nv">$behavior</span>:long int
kernel.statement<span class="o">(</span><span class="s2">"SyS_madvise@mm/madvise.c:477"</span><span class="o">)</span> <span class="nv">$start</span>:long int <span class="nv">$len_in</span>:long int <span class="nv">$behavior</span>:long int
</code></pre></div></div>

<h4 id="systemtap-常用函数">systemtap 常用函数</h4>

<p>tid() 获得当前执行线程的thread id</p>

<p>经常可以写这样的小Probe 来验证这句话对不对</p>

<p>sudo stap -e ‘probe begin { printf(“%d\n”, gettimeofday_s()) }’</p>

<h4 id="2008-内核线上systemtap-安装">2.0.0.8 内核线上systemtap 安装</h4>

<p>wget http://xxxxxxxxxxxxxxxxxxxxxxxxxx/kernel/rs-2.0.0.8.tar.gz</p>

<p>这个是线上centos 6.2 的内核需要的包. 主要包含以下内容</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─[<span class="nv">$]</span> <span class="nb">tar</span> <span class="nt">-zxvf</span> rs-2.0.0.8.tar.gz
rs-2.0.0.8/
rs-2.0.0.8/perf-2.6.32-220.7.1.el6.2.0.0.8.x86_64.rpm
rs-2.0.0.8/kernel-2.6.32-220.7.1.el6.2.0.0.8.x86_64.rpm
rs-2.0.0.8/kernel-debuginfo-2.6.32-220.7.1.el6.2.0.0.8.x86_64.rpm
rs-2.0.0.8/kernel-devel-2.6.32-220.7.1.el6.2.0.0.8.x86_64.rpm
rs-2.0.0.8/perf-debuginfo-2.6.32-220.7.1.el6.2.0.0.8.x86_64.rpm
rs-2.0.0.8/kernel-firmware-2.6.32-220.7.1.el6.2.0.0.8.x86_64.rpm
rs-2.0.0.8/kernel-headers-2.6.32-220.7.1.el6.2.0.0.8.x86_64.rpm
rs-2.0.0.8/python-perf-2.6.32-220.7.1.el6.2.0.0.8.x86_64.rpm
rs-2.0.0.8/kernel-debuginfo-common-x86_64-2.6.32-220.7.1.el6.2.0.0.8.x86_64.rpm
</code></pre></div></div>

<p>找到跟 uname -rn 对应版本的 /lib/modules/<code class="language-plaintext highlighter-rouge">uname -rn</code>/build  指向 /usr/src/kernel/uname -rn</p>

<p>尽可能把名字都改成和uname -rn 一样的.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> /lib/modules/2.6.32-220.7.1.el6.2.0.0.8.x86_64/build -&gt; ../../../usr/src/kernels/2.6.32-220.7.1.el6.2.0.0.8.x86_64
</code></pre></div></div>

<p>如果还有问题, 比如没有对应kernel 版本对应的代码等等, 为了能够让systemtap 跑起来, 比如可以跑 nd_syscall 这些命令也是很有用, 不需要符号表, 那么直接将</p>

<p>/usr/src/kernels/2.6.32-220.7.1.el6.2.0.0.8.x86_64/include/linux/utsrelease.h 里面的内核版本改成uname -rn 里面显示的版本就行</p>

<h4 id="systemtap-配套工具">systemtap 配套工具</h4>

<p>addr2line -e ./a.out 0x4004a6</p>

<p>通过 print_ubacktrace() 可以详细的看到函数的调用栈, 这个时候再用addr2line 去获得对应地址的代码</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brkcall 0x80fee4000
 0x34794e0a4a : brk+0xa/0x70 <span class="o">[</span>/lib64/libc-2.12.so]
 0x34794e0af5 : __sbrk+0x45/0xa0 <span class="o">[</span>/lib64/libc-2.12.so]
 0x7f33e850c160 : sbrk+0x40/0xe0 <span class="o">[</span>/usr/local/pika22/lib/libtcmalloc.so.4]
 0x7f33e84f55c3 : _ZN16SbrkSysAllocator5AllocEmPmm+0x53/0xd0 <span class="o">[</span>/usr/local/pika22/lib/libtcmalloc.so.4]
 0x7f33e84f5546 : _ZN19DefaultSysAllocator5AllocEmPmm+0x36/0x60 <span class="o">[</span>/usr/local/pika22/lib/libtcmalloc.so.4]
 0x7f33e84f5a0c : _Z20TCMalloc_SystemAllocmPmm+0x6c/0xd0 <span class="o">[</span>/usr/local/pika22/lib/libtcmalloc.so.4]
 0x7f33e84f7905 : _ZN8tcmalloc8PageHeap8GrowHeapEm+0x65/0x360 <span class="o">[</span>/usr/local/pika22/lib/libtcmalloc.so.4]
 0x7f33e84f7c2b : _ZN8tcmalloc8PageHeap3NewEm+0x2b/0x40 <span class="o">[</span>/usr/local/pika22/lib/libtcmalloc.so.4]
 0x7f33e8506c4a : tc_malloc+0x5aa/0x800 <span class="o">[</span>/usr/local/pika22/lib/libtcmalloc.so.4]
 0x711d7d : _ZN4pink9RedisConnC2EiRKSs+0x8d/0xa0 <span class="o">[</span>/usr/local/pika22/bin/pika]
 0x4f29d1 : _ZN14PikaClientConnC1EiSsPN4pink6ThreadE+0x11/0x80 <span class="o">[</span>/usr/local/pika22/bin/pika]
 0x55480c : _ZN4pink12WorkerThreadI14PikaClientConnE10ThreadMainEv+0x33c/0x7a0 <span class="o">[</span>/usr/local/pika22/bin/pika]
 0x70fbfd : _ZN4pink6Thread9RunThreadEPv+0x9d/0x180 <span class="o">[</span>/usr/local/pika22/bin/pika]
 0x3479807aa1 : start_thread+0xd1/0x3d4 <span class="o">[</span>/lib64/libpthread-2.12.so]
 0x34794e8bcd : __clone+0x6d/0x90 <span class="o">[</span>/lib64/libc-2.12.so]
</code></pre></div></div>

<p>那么这里你就可以使用</p>

<p>addr2line -e /usr/local/pika22/bin/pika 0x711d7d 看到对应的申请的代码了</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[xusiliang@redis220 ~]$ addr2line -e /usr/local/pika22/bin/pika 0x711d7d
/data1/songzhao/Develop/pika/third/pink/src/redis_conn.cc:139
</code></pre></div></div>

<h4 id="systemtap-example">systemtap example</h4>

<p>写的example, 通过example 可以很快的了解常用的语法</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/usr/bin/stap</span>

probe begin
<span class="o">{</span>
  log<span class="o">(</span><span class="s2">"begin to probe</span><span class="se">\n</span><span class="s2">"</span><span class="o">)</span>
<span class="o">}</span>

/<span class="k">*</span>
 <span class="k">*</span> 这里是probe 系统调用的写法
 <span class="k">*</span>/
probe syscall.madvise
<span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span>execname<span class="o">()</span> <span class="o">==</span> <span class="s2">"a.out"</span><span class="o">)</span> <span class="o">{</span>
    /<span class="k">*</span>
     <span class="k">*</span> 这里通过stap <span class="nt">-L</span> syscall.madvise 可以获得可以 probe 的几个变量的值
     <span class="k">*</span> 那么这里就可以把这些变量都打印出来
     <span class="k">*</span>/
    <span class="nb">printf</span><span class="o">(</span><span class="s2">"%d %d %d</span><span class="se">\n</span><span class="s2">"</span>, <span class="nv">$start</span>, <span class="nv">$len_in</span>, <span class="nv">$behavior</span><span class="o">)</span><span class="p">;</span>

    <span class="nb">printf</span><span class="o">(</span><span class="s2">"write %s</span><span class="se">\n</span><span class="s2">"</span>, name<span class="o">)</span><span class="p">;</span>
    <span class="nb">printf</span><span class="o">(</span><span class="s2">"thread_indent</span><span class="se">\n</span><span class="s2">%s</span><span class="se">\n</span><span class="s2">"</span>, thread_indent<span class="o">(</span>1<span class="o">))</span><span class="p">;</span>

    /<span class="k">*</span>
     <span class="k">*</span> vars 是打印出所有的参数, vars 是打印所有函数里面的本地局部变量
     <span class="k">*</span> parms 是包含上面的两个
     <span class="k">*</span>/
    <span class="nb">printf</span><span class="o">(</span><span class="s2">"vars %s</span><span class="se">\n</span><span class="s2">"</span>, <span class="nv">$$</span>vars<span class="nv">$)</span>
    <span class="nb">printf</span><span class="o">(</span><span class="s2">"locals %s</span><span class="se">\n</span><span class="s2">"</span>, <span class="nv">$$</span>locals<span class="o">)</span>
    <span class="nb">printf</span><span class="o">(</span><span class="s2">"parms %s</span><span class="se">\n</span><span class="s2">"</span>, <span class="nv">$$</span>parms<span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
probe syscall.madvise.return
<span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span>execname<span class="o">()</span> <span class="o">==</span> <span class="s2">"a.out"</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="nv">$return</span> &lt; 0<span class="o">)</span> <span class="o">{</span>
      print_regs<span class="o">()</span>
      print_backtrace<span class="o">()</span>
    <span class="o">}</span>
    <span class="nb">printf</span><span class="o">(</span><span class="s2">"%d %d %d</span><span class="se">\n</span><span class="s2">"</span>, <span class="nv">$start</span>, <span class="nv">$len_in</span>, <span class="nv">$behavior</span><span class="o">)</span><span class="p">;</span>

    <span class="nb">printf</span><span class="o">(</span><span class="s2">"write %s</span><span class="se">\n</span><span class="s2">"</span>, name<span class="o">)</span><span class="p">;</span>
    <span class="nb">printf</span><span class="o">(</span><span class="s2">"thread_indent</span><span class="se">\n</span><span class="s2">%s</span><span class="se">\n</span><span class="s2">"</span>, thread_indent<span class="o">(</span><span class="nt">-1</span><span class="o">))</span><span class="p">;</span>
  <span class="o">}</span>
<span class="o">}</span>

/<span class="k">*</span>
 <span class="k">*</span> 具体probe 函数里面的某一行
 <span class="k">*</span>/
probe kernel.function<span class="o">(</span><span class="s2">"*@mm/madvise.c:488"</span><span class="o">)</span>
<span class="o">{</span>
  <span class="nb">printf</span><span class="o">(</span><span class="s2">"current end %d</span><span class="se">\n</span><span class="s2">"</span>, <span class="nv">$end</span><span class="o">)</span>
<span class="o">}</span>

/<span class="k">*</span>
 <span class="k">*</span> 当需要probe 两个函数, 但是都是一样处理结果的时候 用逗号<span class="o">(</span>,<span class="o">)</span> 分开
 <span class="k">*</span>/
probe kernel.function<span class="o">(</span><span class="s2">"tlb_finish_mmu"</span><span class="o">)</span>, kernel.function<span class="o">(</span><span class="s2">"madvise_hwpoison"</span><span class="o">)</span>
<span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span>execname<span class="o">()</span> <span class="o">==</span> <span class="s2">"a.out"</span><span class="o">)</span> <span class="o">{</span>
    <span class="nb">printf</span><span class="o">(</span><span class="s2">"vars %s</span><span class="se">\n</span><span class="s2">"</span>, <span class="nv">$$</span>vars<span class="nv">$)</span>
    <span class="nb">printf</span><span class="o">(</span><span class="s2">"thread_indent</span><span class="se">\n</span><span class="s2">%s</span><span class="se">\n</span><span class="s2">"</span>, thread_indent<span class="o">(</span><span class="nt">-1</span><span class="o">))</span><span class="p">;</span>
    print_backtrace<span class="o">()</span>
    print_ubacktrace<span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span>

probe kernel.function<span class="o">(</span><span class="s2">"free_pages"</span><span class="o">)</span>
<span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span>execname<span class="o">()</span> <span class="o">==</span> <span class="s2">"a.out"</span><span class="o">)</span> <span class="o">{</span>
    <span class="nb">printf</span><span class="o">(</span><span class="s2">"vars %s</span><span class="se">\n</span><span class="s2">"</span>, <span class="nv">$$</span>vars<span class="nv">$)</span>
    <span class="nb">printf</span><span class="o">(</span><span class="s2">"thread_indent</span><span class="se">\n</span><span class="s2">%s</span><span class="se">\n</span><span class="s2">"</span>, thread_indent<span class="o">(</span><span class="nt">-1</span><span class="o">))</span><span class="p">;</span>
    print_backtrace<span class="o">()</span>
    print_ubacktrace<span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span>


probe kernel.function<span class="o">(</span><span class="s2">"madvise_behavior_valid"</span><span class="o">)</span>
<span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span>execname<span class="o">()</span> <span class="o">==</span> <span class="s2">"a.out"</span><span class="o">)</span> <span class="o">{</span>
    print_backtrace<span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>probe syscall.brk
<span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span>execname<span class="o">()</span> <span class="o">==</span> <span class="s2">"a.out"</span><span class="o">)</span> <span class="o">{</span>

    <span class="nb">printf</span><span class="o">(</span><span class="s2">"brkcall %s</span><span class="se">\n</span><span class="s2">"</span>, argstr<span class="o">)</span>
    /<span class="k">*</span> <span class="nb">printf</span><span class="o">(</span><span class="s2">"%d %d %d</span><span class="se">\n</span><span class="s2">"</span>, <span class="nv">$start</span>, <span class="nv">$len_in</span>, <span class="nv">$behavior</span><span class="o">)</span><span class="p">;</span> <span class="k">*</span>/
    <span class="nb">printf</span><span class="o">(</span><span class="s2">"vars %s</span><span class="se">\n</span><span class="s2">"</span>, <span class="nv">$$</span>vars<span class="o">)</span>
    /<span class="k">*</span> 经常发现print_backtrace<span class="o">()</span> 和 print_ubacktrace<span class="o">()</span> 一起用的时候, 打印出来的信息会少很多 <span class="k">*</span>/
    /<span class="k">*</span> print_backtrace<span class="o">()</span> <span class="k">*</span>/
    /<span class="k">*</span> 用来打印出调用brk 系统调用的时候的函数调用栈, 这个时候需要将其他的动态库都传入到stap 的参数列表里面 <span class="k">*</span>/
    /<span class="k">*</span> <span class="o">!</span><span class="nb">sudo </span>stap <span class="nt">-d</span> /usr/lib64/libc-2.17.so <span class="nt">-d</span> /data5/tmp/a.out <span class="nt">-d</span> /usr/lib64/ld-2.17.so <span class="nt">-d</span> /usr/lib64/libtcmalloc.so.4.2.6 <span class="k">*</span>/
    <span class="nb">printf</span><span class="o">(</span><span class="s2">"user space backtrace</span><span class="se">\n</span><span class="s2">"</span><span class="o">)</span>
    print_ubacktrace<span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span>

很多时候如果执行的有问题, 遇到符号表信息不对 等等情况, 可以直接把 syscall 改成nd_syscall 就行, 这样就不需要符号表了
</code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/usr/bin/stap</span>

probe begin
<span class="o">{</span>
  /<span class="k">*</span>
   <span class="k">*</span> 一般开头加上这个, 用于指导Probe 已经开始了, 因为经常probe 要准备一会
   <span class="k">*</span>/
  log<span class="o">(</span><span class="s2">"begin to probe</span><span class="se">\n</span><span class="s2">"</span><span class="o">)</span>
<span class="o">}</span>


/<span class="k">*</span>
 <span class="k">*</span> 这里是probe kernel 里面的某一个函数的写法
 <span class="k">*</span>/
probe kernel.function<span class="o">(</span><span class="s2">"page_remove_rmap"</span><span class="o">)</span>
<span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span>execname<span class="o">()</span> <span class="o">==</span> <span class="s2">"a.out"</span><span class="o">)</span> <span class="o">{</span>

    <span class="nb">printf</span><span class="o">(</span><span class="s2">"%d %s </span><span class="se">\n</span><span class="s2">"</span>, pid<span class="o">()</span>, execname<span class="o">())</span>
    print_backtrace<span class="o">()</span>
    print_ubacktrace<span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span>

/<span class="k">*</span>
 <span class="k">*</span> 这个是去 probe 系统调用返回的时候的写法
 <span class="k">*</span>/
probe syscall.madvise.return
<span class="o">{</span>
  /<span class="k">*</span>
   <span class="k">*</span> 判断如果是 a.out 才打印出相关的信息, 不然信息太多
   <span class="k">*</span>/
  <span class="k">if</span> <span class="o">(</span>execname<span class="o">()</span> <span class="o">==</span> <span class="s2">"a.out"</span><span class="o">)</span> <span class="o">{</span>
    <span class="nb">printf</span><span class="o">(</span><span class="s2">"madvise %d %s (%s)</span><span class="se">\n</span><span class="s2">"</span>, pid<span class="o">()</span>, execname<span class="o">()</span>, argstr<span class="o">)</span>
    /<span class="k">*</span>
     <span class="k">*</span> 经常用, 分别打印出kernel 内部的堆栈和用户空间的堆栈
     <span class="k">*</span>/
    print_backtrace<span class="o">()</span>
    print_ubacktrace<span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span>

/<span class="k">*</span>
 <span class="k">*</span> 这里也是probe kernel 里面的某一个函数的写法
 <span class="k">*</span>/
probe kernel.function<span class="o">(</span><span class="s2">"__free_pages"</span><span class="o">)</span>
<span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span>execname<span class="o">()</span> <span class="o">==</span> <span class="s2">"a.out"</span><span class="o">)</span> <span class="o">{</span>

    <span class="nb">printf</span><span class="o">(</span><span class="s2">"%d %s </span><span class="se">\n</span><span class="s2">"</span>, pid<span class="o">()</span>, execname<span class="o">())</span>
    print_backtrace<span class="o">()</span>
    print_ubacktrace<span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span>

probe kernel.function<span class="o">(</span><span class="s2">"do_munmap"</span><span class="o">)</span>
<span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span>execname<span class="o">()</span> <span class="o">==</span> <span class="s2">"a.out"</span><span class="o">)</span> <span class="o">{</span>

    <span class="nb">printf</span><span class="o">(</span><span class="s2">"%d %s </span><span class="se">\n</span><span class="s2">"</span>, pid<span class="o">()</span>, execname<span class="o">())</span>
    print_backtrace<span class="o">()</span>
    print_ubacktrace<span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span>

probe kernel.function<span class="o">(</span><span class="s2">"free_pages"</span><span class="o">)</span>
<span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span>execname<span class="o">()</span> <span class="o">==</span> <span class="s2">"a.out"</span><span class="o">)</span> <span class="o">{</span>

    <span class="nb">printf</span><span class="o">(</span><span class="s2">"%d %s </span><span class="se">\n</span><span class="s2">"</span>, pid<span class="o">()</span>, execname<span class="o">())</span>
    print_backtrace<span class="o">()</span>
    print_ubacktrace<span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp"># 统计malloc 和 free 分别调用了多少次, 并且看到调用的位置
#!/usr/bin/stap
</span>
<span class="n">probe</span> <span class="n">begin</span>
<span class="p">{</span>
  <span class="n">log</span><span class="p">(</span><span class="s">"begin to probe</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">global</span> <span class="n">nmalloc</span><span class="p">,</span> <span class="n">nfree</span>
<span class="c1">// 这里因为使用的是tcmalloc, 如果使用默认的ptmalloc, 那么这里就是probe process("/lib64/libc.so.6").function("malloc") {</span>

<span class="n">probe</span> <span class="nf">process</span><span class="p">(</span><span class="s">"/usr/local/pika22/lib/libtcmalloc.so.4"</span><span class="p">).</span><span class="n">function</span><span class="p">(</span><span class="s">"malloc"</span><span class="p">),</span> <span class="n">process</span><span class="p">(</span><span class="s">"/usr/local/pika22/lib/libtcmalloc.so.4"</span><span class="p">).</span><span class="n">function</span><span class="p">(</span><span class="s">"realloc"</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">execname</span><span class="p">()</span><span class="o">==</span> <span class="s">"pika"</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">nmalloc</span><span class="o">++</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"malloc %s </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argstr</span><span class="p">)</span>
                <span class="n">print_ubacktrace</span><span class="p">()</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s">"</span><span class="p">)</span>
        <span class="p">}</span>
<span class="p">}</span>

<span class="n">probe</span> <span class="nf">process</span><span class="p">(</span><span class="s">"/usr/local/pika22/lib/libtcmalloc.so.4"</span><span class="p">).</span><span class="n">function</span><span class="p">(</span><span class="s">"free"</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">execname</span><span class="p">()</span><span class="o">==</span> <span class="s">"pika"</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">nfree</span><span class="o">++</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"free %s </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argstr</span><span class="p">)</span>
                <span class="n">print_ubacktrace</span><span class="p">()</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s">"</span><span class="p">)</span>
        <span class="p">}</span>
<span class="p">}</span>

<span class="n">probe</span> <span class="n">timer</span><span class="p">.</span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"malloc %d free %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">nmalloc</span><span class="p">,</span> <span class="n">nfree</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/usr/bin/stap

probe begin
{
  log("begin to probe")
}

probe syscall.brk 
{
  if (execname() == "a.out") {
    printf("brkcall %d %s (%s)\n", pid(), execname(), argstr)
  }
}

probe syscall.mmap2
{
  if (execname() == "a.out") {
    printf("mmap %d %s (%s)\n", pid(), execname(), argstr)
  }
}

probe syscall.madvise
{
  if (execname() == "a.out") {
    printf("madvise %d %s (%s)\n", pid(), execname(), argstr)
  }
}

/* probe syscall.open  */
/* { */
/*   printf("%d %s (%s)\n", pid(), execname(), argstr) */
/* } */

probe timer.ms(10000)
{
  exit()
}

</code></pre></div></div>

<p>用来查看内存泄露的一个工具, 比valgrind 方便的地方在于不用线上跑valgrind, 而且可以精确到线程级别</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 执行方法 sudo stap tm.stp  -d /lib64/libc-2.12.so -d /usr/local/pika22/bin/pika -d /usr/local/pika22/lib/libtcmalloc.so.4 -d /lib64/libpthread-2.12.so</span>

<span class="c">#!/usr/bin/stap</span>

probe begin
<span class="o">{</span>
  log<span class="o">(</span><span class="s2">"begin to probe</span><span class="se">\n</span><span class="s2">"</span><span class="o">)</span>
<span class="o">}</span>

<span class="c"># 对某一个地址调用的malloc, free的次数. </span>
<span class="c"># 如果 = 0, 说明正常free掉, </span>
<span class="c"># 如果 = 1, 说明malloc, 但是还没被free</span>
<span class="c"># 如果 &gt; 1, 说明这个地址被多次给malloc返回给用户, 肯定不正常</span>
<span class="c"># 如果 &lt; 1, 说明这个地址被多次free 也就是我们常说的double free 问题</span>
global g_cnt
<span class="c"># 用来记录前一次调用的时候的 ubacktrace 信息</span>
global g_stack
<span class="c"># 用来记录上次操作的时间</span>
global g_time

probe process<span class="o">(</span><span class="s2">"/usr/local/pika22/lib/libtcmalloc.so.4"</span><span class="o">)</span>.function<span class="o">(</span><span class="s2">"__libc_malloc"</span><span class="o">)</span>.return, process<span class="o">(</span><span class="s2">"/usr/local/pika22/lib/libtcmalloc.so.4"</span><span class="o">)</span>.function<span class="o">(</span><span class="s2">"__libc_calloc"</span><span class="o">)</span>.return

<span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span>tid<span class="o">()</span> <span class="o">==</span> 11808<span class="o">)</span> <span class="o">{</span>
			g_cnt[<span class="nv">$return</span><span class="o">]</span>++
			g_stack[<span class="nv">$return</span><span class="o">]</span> <span class="o">=</span> sprint_ubacktrace<span class="o">()</span>
			g_time[<span class="nv">$return</span><span class="o">]</span> <span class="o">=</span> gettimeofday_s<span class="o">()</span>
	<span class="o">}</span>
<span class="o">}</span>

probe process<span class="o">(</span><span class="s2">"/usr/local/pika22/lib/libtcmalloc.so.4"</span><span class="o">)</span>.function<span class="o">(</span><span class="s2">"__libc_free"</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span>tid<span class="o">()</span> <span class="o">==</span> 11808 <span class="o">&amp;&amp;</span> g_time[<span class="nv">$ptr</span><span class="o">]</span> <span class="o">!=</span> 0<span class="o">)</span> <span class="o">{</span>
    <span class="c"># 这里对于之前没有进行过处理的节点忽略</span>
    g_cnt[<span class="nv">$ptr</span><span class="o">]</span><span class="nt">--</span>
    <span class="c"># 正常的malloc free 分支</span>
		<span class="k">if</span> <span class="o">(</span>g_cnt[<span class="nv">$ptr</span><span class="o">]</span> <span class="o">==</span> 0<span class="o">)</span> <span class="o">{</span>
			<span class="k">if</span> <span class="o">(</span><span class="nv">$ptr</span> <span class="o">!=</span> 0<span class="o">)</span> <span class="o">{</span>
				<span class="nb">printf</span><span class="o">(</span><span class="s2">"A normal malloc and free</span><span class="se">\n</span><span class="s2">"</span><span class="o">)</span>
				g_stack[<span class="nv">$ptr</span><span class="o">]</span> <span class="o">=</span> sprint_ubacktrace<span class="o">()</span>
			<span class="o">}</span>
      <span class="c"># 可能出现的double free 分支</span>
		<span class="o">}</span> <span class="k">else if</span> <span class="o">(</span>g_cnt[<span class="nv">$ptr</span><span class="o">]</span> &lt; 0 <span class="o">&amp;&amp;</span> <span class="nv">$ptr</span> <span class="o">!=</span> 0<span class="o">)</span> <span class="o">{</span>
				<span class="nb">printf</span><span class="o">(</span><span class="s2">"double free problem address %d cnt %d</span><span class="se">\n</span><span class="s2">"</span>, <span class="nv">$ptr</span>, g_cnt[<span class="nv">$ptr</span><span class="o">])</span>
				<span class="nb">printf</span><span class="o">(</span><span class="s2">"%s</span><span class="se">\n</span><span class="s2">"</span>, g_stack[<span class="nv">$ptr</span><span class="o">])</span>
				<span class="nb">printf</span><span class="o">(</span><span class="s2">"the destructure </span><span class="se">\n</span><span class="s2">"</span><span class="o">)</span>
				print_ubacktrace<span class="o">()</span> 
      <span class="c"># 多次malloc 返回同一个地址的分支, 这种情况很少见</span>
		<span class="o">}</span> <span class="k">else if</span> <span class="o">(</span>g_cnt[<span class="nv">$ptr</span><span class="o">]</span> <span class="o">&gt;</span> 1 <span class="o">&amp;&amp;</span> <span class="nv">$ptr</span> <span class="o">!=</span> 0<span class="o">)</span> <span class="o">{</span>
			<span class="nb">printf</span><span class="o">(</span><span class="s2">"malloc large than 0</span><span class="se">\n</span><span class="s2">"</span><span class="o">)</span>
			print_ubacktrace<span class="o">()</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>

probe timer.s<span class="o">(</span>5<span class="o">)</span> <span class="o">{</span>
	foreach <span class="o">(</span>mem <span class="k">in </span>g_cnt<span class="o">)</span> <span class="o">{</span>
    <span class="c"># 这里可以根据定义来调整这个10 的大小, 也就是说这里想打印出 10s 之前申请过内存</span>
    <span class="c"># 但是 10s 之内没有被free 的情况, 这里因为 pika 在短连接的时候都是10之内申请 然后就释放</span>
    <span class="c"># 如果10s 之内没有释放, 那肯定就是内存出现了问题</span>
		<span class="k">if</span> <span class="o">(</span>g_cnt[mem] <span class="o">&gt;</span> 0 <span class="o">&amp;&amp;</span> gettimeofday_s<span class="o">()</span> - g_time[mem] <span class="o">&gt;</span> 10<span class="o">)</span> <span class="o">{</span>
			<span class="nb">printf</span><span class="o">(</span><span class="s2">"</span><span class="se">\n\n</span><span class="s2">%s</span><span class="se">\n\n</span><span class="s2">"</span>, g_stack[mem]<span class="o">)</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>


</code></pre></div></div>


</article>






  <div id="disqus_thread"></div>
  <script type="text/javascript">
    var disqus_shortname  = 'baotiao';
    var disqus_identifier = '/2017/06/14/systemtap-tips-and-example';
    var disqus_title      = 'systemtap tips and examples';

    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>






      </div>
    </div>
  </div>

  <footer class="center">
</footer>


</body>
</html>
