<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>epoll implementation &#8211; baotiao</title>
    <link rel="dns-prefetch" href="//maxcdn.bootstrapcdn.com">
    <link rel="dns-prefetch" href="//cdn.mathjax.org">
    <link rel="dns-prefetch" href="//cdnjs.cloudflare.com">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="做有积累的事情">
    <meta name="robots" content="all">
    <meta name="author" content="baotiao">
    <meta name="keywords" content="">
    <link rel="canonical" href="http://baotiao.github.io//2016/03/06/epoll_implementation/">
    <link rel="alternate" type="application/rss+xml" title="RSS Feed for baotiao" href="/feed.xml" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/pixyll.css?201701242310" type="text/css">

    <!-- Fonts -->
    
    <link href='//fonts.googleapis.com/css?family=Merriweather:900,900italic,300,300italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Lato:900,300' rel='stylesheet' type='text/css'>
    
    

    <!-- MathJax -->
    

    <!-- Verifications -->
    
    

    <!-- Open Graph -->
    <!-- From: https://github.com/mmistakes/hpstr-jekyll-theme/blob/master/_includes/head.html -->
    <meta property="og:locale" content="en_US">
    <meta property="og:type" content="article">
    <meta property="og:title" content="epoll implementation">
    <meta property="og:description" content="epoll implementation">
    <meta property="og:url" content="http://baotiao.github.io//2016/03/06/epoll_implementation/">
    <meta property="og:site_name" content="baotiao">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary" />
    
        <meta name="twitter:site" content="@baotiao" />
    
    <meta name="twitter:title" content="epoll implementation" />
    <meta name="twitter:description" content="做有积累的事情" />
    <meta name="twitter:url" content="http://baotiao.github.io//2016/03/06/epoll_implementation/" />

    <!-- Icons -->
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
    <link rel="icon" type="image/png" href="/favicon-192x192.png" sizes="192x192">
    <link rel="icon" type="image/png" href="/favicon-160x160.png" sizes="160x160">
    <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
    <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
    <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">

    
</head>

<body class="site">
  
	

  <div class="site-wrap">
    <header class="site-header px2 px-responsive">
  <div class="mt2 wrap">
    <div class="measure">
      <a href="http://baotiao.github.io/" class="site-title">baotiao</a>
      <nav class="site-nav">
        
    

    
        <a href="/about/">About</a>
    

    

    

    

    

    

    

    

    

    

    

    

    

    


    

    

    

    

    
        <a href="/links/">Links</a>
    

    

    

    

    

    

    

    

    

    

    


    

    

    

    

    

    
        <a href="/paper/">Paper</a>
    

    

    

    

    

    

    

    

    

    


      </nav>
      <div class="clearfix"></div>
      
    </div>
  </div>
</header>


    <div class="post p2 p-responsive wrap" role="main">
      <div class="measure">
        


<div class="post-header mb2">
  <h1>epoll implementation</h1>
  <span class="post-meta">Mar 6 2016</span><br>
  
  <span class="post-meta small">
  
    20 minute read
  
  </span>
</div>

<article class="post-content">
  <h3 id="epoll-implementation">epoll Implementation</h3>

<p>epoll 在kernel 的具体实现主要在 fs/eventpoll.c include/linux/eventpoll.h 里面</p>

<h4 id="section">主要的数据结构</h4>

<p>eventpoll 是这里面最重要的结构, 在epoll_create 的时候就会生成这个eventpoll 结构, 后续对这个fd 的操作都是在这个eventpoll 这个结构下面的, 这个eventpoll 结构会被保存在file struct 的 private_data 这个结构体里面</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">eventpoll</span> <span class="p">{</span>
	<span class="cm">/* Protect the this structure access */</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>

	<span class="cm">/*
	 * This mutex is used to ensure that files are not removed
	 * while epoll is using them. This is held during the event
	 * collection loop, the file cleanup path, the epoll file exit
	 * code and the ctl operations.
	 */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>

	<span class="cm">/* Wait queue used by sys_epoll_wait() */</span>
  <span class="cm">/*
   * 这个wq 这个等待队列是在sys_epoll_wait 里面使用的,
   * 里面放入的进程应该只有执行epoll_wait 这个进程
   */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">wq</span><span class="p">;</span>

	<span class="cm">/* Wait queue used by file-&gt;poll() */</span>
  <span class="cm">/*
   * 因为eventpoll 本身也是一个file, 所以也会有poll 操作, 有poll
   * 操作肯定就会有一个对应的wait_queue_head_t 队列用来唤醒上面的进程或者函数
   * 就跟pipe_inode_info 里面会有  wait_queue_head_t wait; 一样
   *
   * 不过我们很少看到把一个epoll 的fd 再挂载到另外一个fd 下面
   *
   */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">poll_wait</span><span class="p">;</span>

	<span class="cm">/* List of ready file descriptors */</span>
  <span class="cm">/*
   * 在epoll_wait 阶段, 如果有哪些fd 就绪, 会把就绪的fd 放在这个rdllist 里面
   * 这个rdllist 里面放的是epitem 这个结构
   */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">rdllist</span><span class="p">;</span>

	<span class="cm">/* RB tree root used to store monitored fd structs */</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="n">rbr</span><span class="p">;</span>

	<span class="cm">/*
	 * This is a single linked list that chains all the "struct epitem" that
	 * happened while transfering ready events to userspace w/out
	 * holding -&gt;lock.
	 */</span>
	<span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">ovflist</span><span class="p">;</span>

	<span class="cm">/* The user that created the eventpoll descriptor */</span>
	<span class="k">struct</span> <span class="n">user_struct</span> <span class="o">*</span><span class="n">user</span><span class="p">;</span>
<span class="p">};</span>

</code></pre>
</div>

<p>epitem 这个表示的是每一个加入到eventpoll 的结构里面的fd 的时候, 都会有一个epitem 这个结构体, 这个结构体是是连成一个红黑树挂载eventpoll 下面的, 后续查找某一个fd 是否有事件等等都是在这个epitem 上面进行操作</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cm">/*
 * Each file descriptor added to the eventpoll interface will
 * have an entry of this type linked to the "rbr" RB tree.
 */</span>
<span class="k">struct</span> <span class="n">epitem</span> <span class="p">{</span>
	<span class="cm">/* RB tree node used to link this structure to the eventpoll RB tree */</span>
  <span class="cm">/*
   * 这是这个fd 挂载的红黑树的节点
   */</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="n">rbn</span><span class="p">;</span>

	<span class="cm">/* List header used to link this structure to the eventpoll ready list */</span>
  <span class="cm">/*
   * 这个是将这个epitem 连接到eventpoll 里面的rdllist 的时候list指针
   */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">rdllink</span><span class="p">;</span>

	<span class="cm">/*
	 * Works together "struct eventpoll"-&gt;ovflist in keeping the
	 * single linked chain of items.
	 */</span>
	<span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="cm">/* The file descriptor information this item refers to */</span>
  <span class="cm">/*
   * epoll 监听的fd
   */</span>
	<span class="k">struct</span> <span class="n">epoll_filefd</span> <span class="n">ffd</span><span class="p">;</span>

	<span class="cm">/* Number of active wait queue attached to poll operations */</span>
  <span class="cm">/*
   * 因为一个epitem 可能会被多个eventpoll 监听, 那么就会对应生成多个eppoll_entry
   * 这里nwait 就是记录这个数目
   */</span>
	<span class="kt">int</span> <span class="n">nwait</span><span class="p">;</span>

	<span class="cm">/* List containing poll wait queues */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">pwqlist</span><span class="p">;</span>

	<span class="cm">/* The "container" of this item */</span>
  <span class="cm">/*
   * 当前这个epitem 所属于的eventpoll
   */</span>
	<span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>

	<span class="cm">/* List header used to link this item to the "struct file" items list */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">fllink</span><span class="p">;</span>

	<span class="cm">/* The structure that describe the interested events and the source fd */</span>
	<span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">event</span><span class="p">;</span>
<span class="p">};</span>

<span class="err">```</span><span class="n">c</span>


<span class="n">eppoll_entry</span> 
<span class="err">一个</span><span class="n">epitem</span> <span class="err">关联到一个</span><span class="n">eventpoll</span><span class="p">,</span> <span class="err">就会有一个对应的</span><span class="n">eppoll_entry</span>

<span class="err">```</span><span class="n">c</span>
<span class="cm">/* Wait structure used by the poll hooks */</span>
<span class="k">struct</span> <span class="n">eppoll_entry</span> <span class="p">{</span>
	<span class="cm">/* List header used to link this structure to the "struct epitem" */</span>
  <span class="cm">/*
   * 因为一个epitem 可以会被多个eventpoll 监听, 因为每一个进程打开的这个文件的fd
   * 和epitem 是一一对应的, 因此这里epitem 对应的是多个eppoll_entry,
   * 所以这个llink 会被连接到pwqlist 里面
   */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">llink</span><span class="p">;</span>

	<span class="cm">/* The "base" pointer is set to the container "struct epitem" */</span>
  <span class="cm">/*
   * 对应的epitem
   */</span>
	<span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>

	<span class="cm">/*
	 * Wait queue item that will be linked to the target file wait
	 * queue head.
   * wait_queue_t 里面存的就是wait_queue_head_t 下面具体的内容
	 */</span>
  <span class="cm">/*
 struct __wait_queue {
     unsigned int flags;
  #define WQ_FLAG_EXCLUSIVE	0x01
  // 这里的这个private 一般指向某一个进程task_struct
  void *private;
  wait_queue_func_t func;
  struct list_head task_list;
  };
  */</span>
	<span class="n">wait_queue_t</span> <span class="n">wait</span><span class="p">;</span>

	<span class="cm">/* The wait queue head that linked the "wait" wait queue item */</span>
	<span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">whead</span><span class="p">;</span>
<span class="p">};</span>

</code></pre>
</div>

<h4 id="epollcreate-">epoll_create 的过程</h4>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cm">/*
 * Open an eventpoll file descriptor.
 */</span>
<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">epoll_create1</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Check the EPOLL_* constant for consistency.  */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">EPOLL_CLOEXEC</span> <span class="o">!=</span> <span class="n">O_CLOEXEC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">EPOLL_CLOEXEC</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="cm">/*
	 * Create the internal data structure ("struct eventpoll").
   * 初始化建立这个主题的 eventpoll 这个结构
	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">ep_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="cm">/*
	 * Creates all the items needed to setup an eventpoll file. That is,
	 * a file structure and a free file descriptor.
   *
   * 这个也是一个重要的过程, 将eventpoll 生成的fd绑定到匿名file上, 
   * 因为我们可以看到epoll_create 出来的也是一个文件fd. 那么这个fd
   * 绑定到一个file 以后, 那么这个epoll具体的内容就在这个struct file 上面的
   * private_data 上面
   *
   * 这里这个error 写的比较坑, 如果正常其实这里返回的就是epoll_create
   * 生成的fd
	 */</span>

  <span class="c1">// 这里这个ep 就是一直要传下去的epollevent, 最后这个ep 会被赋值到struct
</span>  <span class="c1">// file-&gt;private_data 里面去
</span>  <span class="c1">// 可以看到这里代表着另外一种文件类型, 匿名文件类型需要建立一个fd的过程
</span>  <span class="c1">// 这里其实如果是socket 的话, 那么不一样的地方就是这里传入的不是ep,
</span>  <span class="c1">// 而是一个socket
</span>  <span class="c1">// 这也是linux 所有数据都是文件的一个体现
</span>	<span class="n">error</span> <span class="o">=</span> <span class="n">anon_inode_getfd</span><span class="p">(</span><span class="s">"[eventpoll]"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eventpoll_fops</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span>
				 <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_CLOEXEC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ep_free</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<h4 id="epollctl">epoll_ctl</h4>

<p>epoll_ctl 做的主要事情就是把某一个fd 要监听的事件过载到eventpoll 里面</p>

<div class="highlighter-rouge"><pre class="highlight"><code>
<span class="n">SYSCALL_DEFINE4</span><span class="p">(</span><span class="n">epoll_ctl</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">epfd</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="o">*</span><span class="n">tfile</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">epds</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
  <span class="cm">/*
   * 这里检查这次操作是否有这个操作, 并将用户空间传进来的epoll_event 拷贝到内核空间
   */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep_op_has_event</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epds</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">epoll_event</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">error_return</span><span class="p">;</span>

	<span class="cm">/* Get the "struct file *" for the eventpoll file */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
  <span class="cm">/*
   * 这里就是使用文件的好处了, 根据这个fd, fget 就可以获得当前这个进程fd
   * 号码是pdfd 的file, 然后就操作file 里面的内容, 虽然这里的file 不是正在的file
   * 而是一个匿名文件, 这样操作起来非常的方便
   */</span>
	<span class="n">file</span> <span class="o">=</span> <span class="n">fget</span><span class="p">(</span><span class="n">epfd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_return</span><span class="p">;</span>

	<span class="cm">/* Get the "struct file *" for the target file */</span>
  <span class="cm">/*
   * 这里的epoll_ctl 要关注的那个文件的fd, 也一样根据这个fd 找到这个文件
   */</span>
	<span class="n">tfile</span> <span class="o">=</span> <span class="n">fget</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tfile</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_fput</span><span class="p">;</span>

  <span class="c1">// TODO 这里descriptoer support poll 是什么意思, 是不是有实现poll 函数就行
</span>	<span class="cm">/* The target file descriptor must support poll */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tfile</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">||</span> <span class="o">!</span><span class="n">tfile</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_tgt_fput</span><span class="p">;</span>

	<span class="cm">/*
	 * We have to check that the file structure underneath the file descriptor
	 * the user passed to us _is_ an eventpoll file. And also we do not permit
	 * adding an epoll file descriptor inside itself.
   * 这里可以看到如果把自己的epoll 的fd 添加到 epoll_ctl 里面的fd 是有问题的
	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span> <span class="o">==</span> <span class="n">tfile</span> <span class="o">||</span> <span class="o">!</span><span class="n">is_file_epoll</span><span class="p">(</span><span class="n">file</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error_tgt_fput</span><span class="p">;</span>

	<span class="cm">/*
	 * At this point it is safe to assume that the "private_data" contains
	 * our own data structure.
	 */</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>

	<span class="cm">/*
	 * Try to lookup the file inside our RB tree, Since we grabbed "mtx"
	 * above, we can be sure to be able to use the item looked up by
	 * ep_find() till we release the mutex.
   * 根据这个fd 找出对应的epitem, 这里把所有的epitem 根据fd号挂载到红黑树上
	 */</span>
	<span class="n">epi</span> <span class="o">=</span> <span class="n">ep_find</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">tfile</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">:</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">epi</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">epds</span><span class="p">.</span><span class="n">events</span> <span class="o">|=</span> <span class="n">POLLERR</span> <span class="o">|</span> <span class="n">POLLHUP</span><span class="p">;</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">ep_insert</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">epds</span><span class="p">,</span> <span class="n">tfile</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>

</code></pre>
</div>
<p>那么接下来主要看ep_insert 的过程</p>

<div class="highlighter-rouge"><pre class="highlight"><code>
<span class="cm">/*
 * Must be called with "mtx" held.
 * 这里可以看到往这个队列里面加入一个epoll_event 的过程
 */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">tfile</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">revents</span><span class="p">,</span> <span class="n">pwake</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ep_pqueue</span> <span class="n">epq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">epoll_watches</span><span class="p">)</span> <span class="o">&gt;=</span>
		     <span class="n">max_user_watches</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">epi</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">epi_cache</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Item initialization follow here ... */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">fllink</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">pwqlist</span><span class="p">);</span>
  <span class="cm">/*
   * 这里会反向标记这个epitem 属于的eventpoll
   */</span>
	<span class="n">epi</span><span class="o">-&gt;</span><span class="n">ep</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
  <span class="cm">/*
   * 这里就是去设定 epitem 里面的ffd 字段, 标记里面的ffd 字段
   * 就是初始化好file, fd 字段
   */</span>
	<span class="n">ep_set_ffd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">ffd</span><span class="p">,</span> <span class="n">tfile</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
	<span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span> <span class="o">=</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="n">epi</span><span class="o">-&gt;</span><span class="n">nwait</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">epi</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">EP_UNACTIVE_PTR</span><span class="p">;</span>

	<span class="cm">/* Initialize the poll table using the queue callback */</span>
	<span class="n">epq</span><span class="p">.</span><span class="n">epi</span> <span class="o">=</span> <span class="n">epi</span><span class="p">;</span>
  <span class="cm">/*
   * 这里是注册poll 里面有事件到达的时候的处理函数
   * 在ep_ptable_queue_proc 里面去添加事件到达的时候处理函数
   * init_waitqueue_func_entry(&amp;pwq-&gt;wait, ep_poll_callback);
   */</span>
	<span class="n">init_poll_funcptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epq</span><span class="p">.</span><span class="n">pt</span><span class="p">,</span> <span class="n">ep_ptable_queue_proc</span><span class="p">);</span>

	<span class="cm">/*
	 * Attach the item to the poll hooks and get current event bits.
	 * We can safely use the file* here because its usage count has
	 * been increased by the caller of this function. Note that after
	 * this operation completes, the poll callback can start hitting
	 * the new item.
	 */</span>

  <span class="cm">/* 
   *
   * 这里调用对应的fd 的poll 操作, 看是否有事件到达.
   * 并且注册事件到达的时候poll_table
   * 这里是调用用户关注的fd 的.poll()函数, 不是eventpoll 里面的
   * ep_eventpoll_poll
   */</span>  
	<span class="n">revents</span> <span class="o">=</span> <span class="n">tfile</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">(</span><span class="n">tfile</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">epq</span><span class="p">.</span><span class="n">pt</span><span class="p">);</span>

	<span class="cm">/*
	 * We have to check if something went wrong during the poll wait queue
	 * install process. Namely an allocation for a wait queue failed due
	 * high memory pressure.
	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">nwait</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_unregister</span><span class="p">;</span>

	<span class="cm">/* Add the current item to the list of active epoll hook for this file */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tfile</span><span class="o">-&gt;</span><span class="n">f_lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">fllink</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tfile</span><span class="o">-&gt;</span><span class="n">f_ep_links</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tfile</span><span class="o">-&gt;</span><span class="n">f_lock</span><span class="p">);</span>

	<span class="cm">/*
	 * Add the current item to the RB tree. All RB tree operations are
	 * protected by "mtx", and ep_insert() is called with "mtx" held.
   * 这里是具体把这个epitem 加入到这个eventpoll 的 rb tree 的过程
	 */</span>
	<span class="n">ep_rbtree_insert</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">epi</span><span class="p">);</span>

	<span class="cm">/* We have to drop the new item inside our item list to keep track of it */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* If the file is already "ready" we drop it inside the ready list */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">revents</span> <span class="o">&amp;</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ep_is_linked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rdllist</span><span class="p">);</span>

		<span class="cm">/* Notify waiting tasks that events are available */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">))</span>
			<span class="n">wake_up_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">poll_wait</span><span class="p">))</span>
			<span class="n">pwake</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

</code></pre>
</div>

<p>那么到这里已经将这个fd 注册到对应的eventpoll上, 那么我们看一下这里注册的函数, 函数是</p>

<p>init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);
这个函数ep_ptable_queue_proc 里面又会包含对应的当有事件发生的时候的回调函数 ep_poll_callback</p>

<p>那么接下来就是 ep_table_queue_proc 的实现</p>

<p>在ep_table_queue_proc 里面将当前这个进程注册到了想要监听的fd 的唤醒队列里面, 这个唤醒的行数是 ep_poll_callback,</p>

<p>其实唤醒的时候主要分两种类似
1. 唤醒注册时候的进程, 让注册的进程重新执行. 比如在epoll_wait 的时候对应的唤醒函数就是唤醒这个执行 epoll_wait 的这个进程
2. 唤醒的时候执行注册的某一个函数</p>

<p>这里因为epoll 注册的是唤醒的时候执行注册的某一个函数, 这个函数就是ep_poll_callback</p>

<div class="highlighter-rouge"><pre class="highlight"><code>
<span class="cm">/*
 * This is the callback that is used to add our wait queue to the
 * target file wakeup lists.
 */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ep_ptable_queue_proc</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">whead</span><span class="p">,</span>
				 <span class="n">poll_table</span> <span class="o">*</span><span class="n">pt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="cm">/*
   * 从知道poll_table 的地址去获得这个对应的epitem的地址, 跟kernel 里面list的做法类似
   */</span>
	<span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span> <span class="o">=</span> <span class="n">ep_item_from_epqueue</span><span class="p">(</span><span class="n">pt</span><span class="p">);</span>


  <span class="cm">/*
   * 这里eppoll_entry 是对应于每一个epitem 注册挂载到某一个eventpoll 都会有一个eppoll_entry
   */</span>
	<span class="k">struct</span> <span class="n">eppoll_entry</span> <span class="o">*</span><span class="n">pwq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">nwait</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pwq</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">pwq_cache</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">)))</span> <span class="p">{</span>
    <span class="cm">/*
     * 这里就是把pwq-&gt;wait 这个元素的callback 设置成 ep_poll_callback 这个函数
     * 然后初始化的时候一般把这个private 设置NULL 的原因是
     * 这里当要等待的这个队列被唤醒的时候, 并不在于哪一个进程,
     * 只要唤醒的时候执行指定的函数就可以了
     * 需要看一下唤醒的时候具体是怎么执行的,
     * 是不是唤醒的时候如果注册的是函数就执行指定的函数,
     * 如果是进程就执行指定的进程
     */</span>
		<span class="n">init_waitqueue_func_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pwq</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="n">ep_poll_callback</span><span class="p">);</span>
		<span class="n">pwq</span><span class="o">-&gt;</span><span class="n">whead</span> <span class="o">=</span> <span class="n">whead</span><span class="p">;</span>
		<span class="n">pwq</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">epi</span><span class="p">;</span>
    <span class="c1">// 这里就是将这个要等待的fd 添加到等待队列里面去了,
</span>    <span class="c1">// 这里如果这个要等待的fd是pipe, 那么这里这个whead就是pipe-&gt;wait了
</span>    <span class="c1">// 这里要等待的fd 只有  wait_queue_head_t wait; 这个wait_queue_head,
</span>    <span class="c1">// 然后就是将这里epoll_entry 里面的wait_queue_t wait 连在一起,
</span>    <span class="c1">// 实际他们组合成了一个等待的队列, 然后想取得这个队列里面的元素, 跟kernel
</span>    <span class="c1">// list 一样, 需要根据struct 里面某一个元素的地址, 然后去获得这个元素
</span>    <span class="c1">// 比如这里想反向获得这个 epoll_entry 里面的epitem 就是
</span>    <span class="c1">//   struct epitem *epi = ep_item_from_wait(wait);
</span>		<span class="n">add_wait_queue</span><span class="p">(</span><span class="n">whead</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pwq</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pwq</span><span class="o">-&gt;</span><span class="n">llink</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">pwqlist</span><span class="p">);</span>
		<span class="n">epi</span><span class="o">-&gt;</span><span class="n">nwait</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* We have to signal that an error occurred */</span>
		<span class="n">epi</span><span class="o">-&gt;</span><span class="n">nwait</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre>
</div>

<p>ep_poll_callback</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cm">/*
 * This is the callback that is passed to the wait queue wakeup
 * machanism. It is called by the stored file descriptors when they
 * have events to report.
 * 这里就是被static void __wake_up_common 这个函数下面进行循环调用的
 *
 * 也就是某一个fd 的等待队列里面注册的这个函数的callback,
 * 然后这个fd有事件发生了, 就会执行这个ep_poll_callback 函数了
 *
 * 这个key 参数是从 wake_up_interruptible_poll() 函数里面一直传进来的, 
 * 这里这个key 在这里表示的就是要监听的这个fd 有什么事件 
 *
 * 其实这里epitem 里面已经包含了发生的事件, 和这里的key 参数其实是一样了,
 * 因为并不是所有的device 都会把发生的事件都放在key 这个参数里面的
 *
 * 这个函数主要就是由监听的fd发生事件了, 然后触发这个回调函数, 
 * 然后这里会把触发的fd 添加到eventpoll 中的 rdllist
 *
 */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_poll_callback</span><span class="p">(</span><span class="n">wait_queue_t</span> <span class="o">*</span><span class="n">wait</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sync</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pwake</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
  <span class="cm">/*
   * 因为之前王wait_queue_t 里面放的是epoll_entry 这个struct 里面的wait 元素,
   * 这里加入的地方是在eventpoll.c:ep_ptable_queue_proc
   * 这个函数里面的
   * add_wait_queue(whead, &amp;pwq-&gt;wait);
   * 在这个函数里面有详细的注释
   * 这样要做的事情就是根据struct 里面的某一个元素wait, 去获得这个struct
   * epoll_entry 里面的epitem
   * 到这里的时候, 我们已经知道是这个epitem 里面指定的fd 有时间发生,
   * 那么这个时候就去检查这个fd 里面发生了什么事件
   */</span>
	<span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span> <span class="o">=</span> <span class="n">ep_item_from_wait</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>


  <span class="cm">/*
   * 这里由于需要记录这个epitem 是属于哪一个eventpoll, 因此epitem
   * 会保留这个反向的指向eventpoll 的指针
   */</span>
	<span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">epi</span><span class="o">-&gt;</span><span class="n">ep</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*
	 * If the event mask does not contain any poll(2) event, we consider the
	 * descriptor to be disabled. This condition is likely the effect of the
	 * EPOLLONESHOT bit that disables the descriptor when an event is received,
	 * until the next EPOLL_CTL_MOD will be issued.
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">EP_PRIVATE_BITS</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="cm">/*
	 * Check the events coming with the callback. At this stage, not
	 * every device reports the events in the "key" parameter of the
	 * callback. We need to be able to handle both cases here, hence the
	 * test for "key" != NULL before the event match test.
   * 这里其实key 有可能记录了当前这个fd的事件, 如果记录了,
   * 就判断key里面返回的事件和 这个fd关注的事件是否有重合
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">key</span> <span class="o">&amp;</span> <span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">events</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="cm">/*
	 * If we are trasfering events to userspace, we can hold no locks
	 * (because we're accessing user memory, and because of linux f_op-&gt;poll()
	 * semantics). All the events that happens during that period of time are
	 * chained in ep-&gt;ovflist and requeued later on.
	 */</span>
  <span class="cm">/*
   * 这里把这个epi 添加到ovflist
   */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ovflist</span> <span class="o">!=</span> <span class="n">EP_UNACTIVE_PTR</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="n">EP_UNACTIVE_PTR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">epi</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ovflist</span><span class="p">;</span>
			<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ovflist</span> <span class="o">=</span> <span class="n">epi</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If this file is already in the ready list we exit soon */</span>
  <span class="c1">// 这个epitem 已经在rdllist 里面就不再添加
</span>  <span class="c1">// 这里只要判断这个epitem-&gt;rdllink 是否有连接上, 也就是next
</span>  <span class="c1">// 指针是否为空就可以知道这个epitem 有没有被连接成一个List
</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep_is_linked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">))</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rdllist</span><span class="p">);</span>

	<span class="cm">/*
	 * Wake up ( if active ) both the eventpoll wait list and the -&gt;poll()
	 * wait list.
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">))</span>
		<span class="n">wake_up_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span> <span class="c1">// 这里的wake_up ep-&gt;wq 就把等待在epoll_wait 里面的直接schedule_timeout()的那个函数给唤醒
</span>  <span class="c1">// 那么这个时候如果进程等待在epoll_wait 上面, 进程就会重新执行
</span>	<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">poll_wait</span><span class="p">))</span> <span class="c1">// 这里这个默认的pwake 初始化是0, 表示当前这个ep-&gt;poll_wait 所等待的fd 里面有多少个已经wakeup了
</span>    <span class="c1">// 为什么这里需要把加这个pwake, 因为如果不加这个pwake, 那么每一个ep
</span>    <span class="c1">// 所等待的fd 醒来都去wakeup 一下这个ep这个线程,
</span>    <span class="c1">// 那么ep这个线程其实就被wakeup 了很多次
</span>		<span class="n">pwake</span><span class="o">++</span><span class="p">;</span>

<span class="nl">out_unlock:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* We have to call this outside the lock */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pwake</span><span class="p">)</span>
		<span class="n">ep_poll_safewake</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">poll_wait</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

</code></pre>
</div>

<h4 id="epollwait">epoll_wait</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>
<span class="cm">/*
 * Implement the event wait interface for the eventpoll file. It is the kernel
 * part of the user space epoll_wait(2).
 */</span>
<span class="n">SYSCALL_DEFINE4</span><span class="p">(</span><span class="n">epoll_wait</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">epfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span>
		<span class="kt">int</span><span class="p">,</span> <span class="n">maxevents</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">...</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">ep_poll</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">maxevents</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>

</code></pre>
</div>

<p>主要的执行逻辑在 ep_poll() 上</p>

<p>ep_poll()</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">__user</span> <span class="o">*</span><span class="n">events</span><span class="p">,</span>
		   <span class="kt">int</span> <span class="n">maxevents</span><span class="p">,</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">,</span> <span class="n">eavail</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">jtimeout</span><span class="p">;</span>
	<span class="n">wait_queue_t</span> <span class="n">wait</span><span class="p">;</span>

	<span class="cm">/*
	 * Calculate the timeout by checking for the "infinite" value (-1)
	 * and the overflow condition. The passed timeout is in milliseconds,
	 * that why (t * HZ) / 1000.
	 */</span>
	<span class="n">jtimeout</span> <span class="o">=</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">timeout</span> <span class="o">&gt;=</span> <span class="n">EP_MAX_MSTIMEO</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">MAX_SCHEDULE_TIMEOUT</span> <span class="o">:</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">*</span> <span class="n">HZ</span> <span class="o">+</span> <span class="mi">999</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>

<span class="nl">retry:</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rdllist</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*
		 * We don't have any available event to return to the caller.
		 * We need to sleep here, and we will be wake up by
		 * ep_poll_callback() when events will become available.
     *
     * 由于ep_poll 是被epoll_wait 的时候被调用, 因此这里这个current
     * 进程就是调用epoll_wait 的那个进程
     *
     * 将这个触发当前进程执行的wait_queue_t wait 加入到ep-&gt;wq wait_queue_head_t
     * 里面去, 那么下次这个wait_queue 有事件到达的时候, 就会触发当前这个wait
     * 里面的内容
		 */</span>
		<span class="n">init_waitqueue_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
		<span class="n">wait</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">WQ_FLAG_EXCLUSIVE</span><span class="p">;</span>
		<span class="n">__add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

    <span class="cm">/*
     * 这里这个死循环的做法是将current 进程的状态改成TASK_INTERRUPTIBLE,
     * 然后最后重新陷入到执行schedule(),
     * 这里因为当前的进程的状态已经改成TASK_INTERRUPTIBLE了,
     * 因此肯定会切换到其他进程去执行
     */</span>
		<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
			<span class="cm">/*
			 * We don't want to sleep if the ep_poll_callback() sends us
			 * a wakeup in between. That's why we set the task state
			 * to TASK_INTERRUPTIBLE before doing the checks.
			 */</span>
			<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
      <span class="cm">/*
       * 这里可以看到如果有ep rdllist 里面有元素, 那么说明有时间已经出发了,
       * 那么就退出这个for 循环
       */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rdllist</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">jtimeout</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
      <span class="cm">/*
       * 当前这个进程把CPU 交给其他的进程执行, 当切换回来的时候肯定eventpoll
       * 里面的内容应该会被修改了, 比如某一个事件触发的时候, 会往rdllist
       * 里面写入数据内容
       *
       * 这里就开始等待之前在epoll_insert
       * 注册的ep_poll_callback这个函数来把当前这个进程给唤醒,
       * 否则是sleep一段时间以后就返回了
       */</span>
			<span class="n">jtimeout</span> <span class="o">=</span> <span class="n">schedule_timeout</span><span class="p">(</span><span class="n">jtimeout</span><span class="p">);</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
    <span class="cm">/*
     * 当前这个进程已经被唤醒, 那么就从eventpoll 里面把这个进程删除掉
     */</span>
		<span class="n">__remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

    <span class="cm">/*
     * 设置当前的进程的状态, 到这里我觉得进程已经正常运行了
     */</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Is it worth to try to dig for events ? */</span>
	<span class="n">eavail</span> <span class="o">=</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rdllist</span><span class="p">)</span> <span class="o">||</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ovflist</span> <span class="o">!=</span> <span class="n">EP_UNACTIVE_PTR</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*
	 * Try to transfer events to user space. In case we get 0 events and
	 * there's still timeout left over, we go trying again in search of
	 * more luck.
   * 到这里肯定从schedule_timeout 里面退出, 已经有事件发生并且传送过来了,
   * 这个就是就把这些事件传给用户进程
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span> <span class="o">&amp;&amp;</span> <span class="n">eavail</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">res</span> <span class="o">=</span> <span class="n">ep_send_events</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">maxevents</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">jtimeout</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

</code></pre>
</div>

<p>最后就是将发生的events 传递给用户空间</p>

<p>ep_send_events-&gt;ep_scan_ready_list-&gt;ep_send_events_proc</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cm">/**
 * ep_scan_ready_list - Scans the ready list in a way that makes possible for
 *                      the scan code, to call f_op-&gt;poll(). Also allows for
 *                      O(NumReady) performance.
 *
 * @ep: Pointer to the epoll private data structure.
 * @sproc: Pointer to the scan callback.
 * @priv: Private opaque data passed to the @sproc callback.
 *
 * Returns: The same integer error code returned by the @sproc callback.
 */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_scan_ready_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sproc</span><span class="p">)(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
			      <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">pwake</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">,</span> <span class="o">*</span><span class="n">nepi</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">txlist</span><span class="p">);</span>

	<span class="cm">/*
	 * We need to lock this because we could be hit by
	 * eventpoll_release_file() and epoll_ctl().
	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>

	<span class="cm">/*
	 * Steal the ready list, and re-init the original one to the
	 * empty list. Also, set ep-&gt;ovflist to NULL so that events
	 * happening while looping w/out locks, are not lost. We cannot
	 * have the poll callback to queue directly on ep-&gt;rdllist,
	 * because we want the "sproc" callback to be able to do it
	 * in a lockless way.
	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

  <span class="c1">// 这里将txlist 指向eventpoll 里面的rdllist, 那么接下来就会将txlist
</span>  <span class="c1">// 里面的内容也就是rdllist里面的内容拷贝给用户空间
</span>  <span class="c1">// 这个rdllist 是在ep_poll_callback 的时候添加进去的内容的
</span>  <span class="c1">// 这里执行完这个list_splice_init 以后, ep-&gt;rdllist 就变成空的了
</span>  <span class="c1">// 那么接下来可以同时处理txllist 里面的内容, 也就是原先rdllist 里面的内容.
</span>  <span class="c1">// 也可以同时让新的元素往这个队里里面添加新的内容
</span>  <span class="c1">//
</span>  <span class="c1">// 这是一个很好的减少锁范围的例子
</span>  <span class="c1">// 相当于先生成一个队列, 然后后续要处理这个队列里面内容,
</span>  <span class="c1">// 同时又添加和删除操作的时候, 可以把这个添加操作放到一个新的队列上,
</span>  <span class="c1">// 那么这个时候就可以同时的添加和删除操作, 不用去竞争一个锁
</span>  <span class="c1">// NICE
</span>	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rdllist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txlist</span><span class="p">);</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ovflist</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*
	 * Now call the callback function.
   * 这里的sproc 就是 ep_send_events_proc
	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">sproc</span><span class="p">)(</span><span class="n">ep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txlist</span><span class="p">,</span> <span class="n">priv</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/*
	 * During the time we spent inside the "sproc" callback, some
	 * other events might have been queued by the poll callback.
	 * We re-insert them inside the main ready-list here.
	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">nepi</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">ovflist</span><span class="p">;</span> <span class="p">(</span><span class="n">epi</span> <span class="o">=</span> <span class="n">nepi</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
	     <span class="n">nepi</span> <span class="o">=</span> <span class="n">epi</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">epi</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">EP_UNACTIVE_PTR</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*
		 * We need to check if the item is already in the list.
		 * During the "sproc" callback execution time, items are
		 * queued into -&gt;ovflist but the "txlist" might already
		 * contain them, and the list_splice() below takes care of them.
		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep_is_linked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">))</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rdllist</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*
	 * We need to set back ep-&gt;ovflist to EP_UNACTIVE_PTR, so that after
	 * releasing the lock, events will be queued in the normal way inside
	 * ep-&gt;rdllist.
	 */</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">ovflist</span> <span class="o">=</span> <span class="n">EP_UNACTIVE_PTR</span><span class="p">;</span>

</code></pre>
</div>

<p>ep_send_events_proc 函数</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// 这里priv 就是用户传进来的events 的包装 ep_send_events_data
// 这里就是具体的把已经就绪的list copy 给用户空间
</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_send_events_proc</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
			       <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
  <span class="cm">/*
   * 这里esed 里面的内容就是 ep-&gt;rdllist 里面的内容
   */</span>
	<span class="k">struct</span> <span class="n">ep_send_events_data</span> <span class="o">*</span><span class="n">esed</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">eventcnt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">revents</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uevent</span><span class="p">;</span>

	<span class="cm">/*
	 * We can loop without lock because we are passed a task private list.
	 * Items cannot vanish during the loop because ep_scan_ready_list() is
	 * holding "mtx" during this call.
	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">eventcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">uevent</span> <span class="o">=</span> <span class="n">esed</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">;</span>
	     <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">eventcnt</span> <span class="o">&lt;</span> <span class="n">esed</span><span class="o">-&gt;</span><span class="n">maxevents</span><span class="p">;)</span> <span class="p">{</span>
		<span class="n">epi</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epitem</span><span class="p">,</span> <span class="n">rdllink</span><span class="p">);</span>

    <span class="cm">/*
     * 这里就是默认将这个有时间到达的epi从这个rdllist 里面删除掉了,
     * 下面可以看到如果是epoll LT 模式的话, 这个epi-&gt;rdllink
     * 会重新被加入到这个rdllist 里面
     */</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">);</span>

    <span class="cm">/*
     * 返回当前这个监听的fd的事件 &amp; 这个fd 我们关注的事件
     */</span>
		<span class="n">revents</span> <span class="o">=</span> <span class="n">epi</span><span class="o">-&gt;</span><span class="n">ffd</span><span class="p">.</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">ffd</span><span class="p">.</span><span class="n">file</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;</span>
			<span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">events</span><span class="p">;</span>

		<span class="cm">/*
		 * If the event mask intersect the caller-requested one,
		 * deliver the event to userspace. Again, ep_scan_ready_list()
		 * is holding "mtx", so no operations coming from userspace
		 * can change the item.
		 */</span>
    <span class="cm">/*
     * 如果这个fd发生的事件有我们关注的事件,
     * 那么我们就把这个事件返回到用户空间去
     */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">revents</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">__put_user</span><span class="p">(</span><span class="n">revents</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uevent</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">)</span> <span class="o">||</span>
			    <span class="n">__put_user</span><span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uevent</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/*
         * 这里是向用户空间拷贝函数失败的分支
         * 这里是如果失败, 那么直接返回当前有多少个事件
         * 如果一个事件也没用, 那么直接返回EFAULT
         */</span>
				<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">eventcnt</span> <span class="o">?</span> <span class="n">eventcnt</span> <span class="o">:</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">eventcnt</span><span class="o">++</span><span class="p">;</span>
			<span class="n">uevent</span><span class="o">++</span><span class="p">;</span>
      <span class="c1">// 这里上面这个分支就是EPOLLET 的情况
</span>			<span class="k">if</span> <span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EPOLLONESHOT</span><span class="p">)</span>
				<span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">&amp;=</span> <span class="n">EP_PRIVATE_BITS</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EPOLLET</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/*
         * 这里是EPOLLLT 的情况, EPOLLLT 是默认情况, 从这里看出, LT
         * 模式会将这个fd重新加入到这个rdllist 里面, 那么下次会再通知这个fd
         * 里面的事件. 那么问题来了, 什么时候才会从这个rdllist 里面删除呢?
         * 
         * 这个删除操作是默认都做的, 就在上面
         * list_del_init(&amp;epi-&gt;rdllink);
         *
         * 比如说pipe 写进来了5个byte 的内容, 第一次读取了2个字节, 然后就返回了,
         * 在下一次执行epoll_wai()的时候, 因为LT 模式默认又加入了rdllist里面,
         * 所有会再一次检查这个fd 里面的状态, 这个时候发现里面还是有数据,
         * 就再一次返回给用户这个状态是
         *
         * 如果是ET模式, 这里可以看到不会添加回去这个rdllist,
         * 那么只有等到这个pipe里面再写入数据的时候才会触发ep_poll_callback把这个fd添加到rdllist里面,
         *
         * 从这里可以看出EPOLL_LT模式是多做了一次的检查,
         * 因为每次完成以后又会加入到这个rdllist里面, 因此性能肯定不如ET模式,
         * 但是ET模式存在说如果一次读取fd没有都读完,
         * 那么必须等到这个fd再有事件过来, 才会通知这个fd
         *
         * 另外一个问题: 这里直接往rdllist 里面添加元素, 这里遍历这个txlist
         * 不会直接把这个元素给遍历到么? 因为这里正好添加到了这个list的尾部.
         * 注释里面为什么写着是下一次的 epoll_wait 在进行一次判断呢?
         *
         * 答: 这里是epoll 实现的时候对锁粒度的一个优化, 每一次有时间的epitem
         * 是存入到idllist 这个队列里面, 然后在进行要传给用户空间操作的时候
         * ep_send_events_proc, 在上面讲这个idllist 的指针传递给了txlist指针,
         * 那么接下来就可以同时往idllist 里面添加元素,
         * 又可以处理txlist(也就是原先的rdllist)上面的内容, 这里就不需要加锁了
         */</span>
				<span class="cm">/*
				 * If this file has been added with Level
				 * Trigger mode, we need to insert back inside
				 * the ready list, so that the next call to
				 * epoll_wait() will check again the events
				 * availability. At this point, noone can insert
				 * into ep-&gt;rdllist besides us. The epoll_ctl()
				 * callers are locked out by
				 * ep_scan_ready_list() holding "mtx" and the
				 * poll callback will queue them in ep-&gt;ovflist.
				 */</span>
				<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rdllist</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">eventcnt</span><span class="p">;</span>
<span class="p">}</span>

</code></pre>
</div>

<h3 id="tips">Tips:</h3>

<h5 id="fd">如何唤醒监听的fd</h5>

<p>这里加入我们有队列注册在某一个fd 上面, 那么当这个fd 有时间到达的时候, 是如何唤醒这个队列里面所有的进程呢</p>

<p>比如具体的 socket 类型的文件, 那么当这个文件有事件到达的时候, 如何进行唤醒的呢?
这里比如tcp 调用的就是  tcp_prequeue 方法, 然后里面有 wake_up_interruptible_poll
这里wake_up_interruptible_poll 就是去调用一个唤醒队列的方法了
最后都会调用到kernel/sched.c:__wake_up_common 方法
这里就跟进程的调度模块比较相关了</p>

<h5 id="fileoperations-poll-">对了file_operations 里面的poll 操作的解释</h5>

<p>poll(file, poll_table)
Checks whether there is activity on a file and goes to sleep until something happens on it.
可以看上一个blog</p>

<h5 id="fd--">当一个fd上面有事件发生的时候, 是会唤醒监听这个文件上等待的进程的. 这个是怎么做到的?</h5>

<p>每一个设备在linux 看来都是一个文件, 那么对于文件操作来说, 每一个都需要实现file_operations 里面的poll 这个操作, 这个操作的意思是检查这个fd是否活动, 可以看上一篇blog 对应的pollc操作</p>

<p>比如以 pipe 的实现举例子的话</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="p">{</span>
  <span class="n">wait_queue_head_t</span> <span class="n">wait</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nrbufs</span><span class="p">,</span> <span class="n">curbuf</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">tmp_page</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">readers</span><span class="p">;</span>

<span class="err">这里有一个</span><span class="n">pipe_inode_info</span><span class="p">,</span> <span class="err">如果当这个</span><span class="n">pipe</span> <span class="err">有数据写入的时候</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="n">pipe_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">_iov</span><span class="p">,</span>
     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="c1">// 所有的read 操作执行完以后, 判断时候需要做wakeup 操作
</span>    <span class="c1">// 需要做wakeup操作的话, 则把之前注册在这个pipe_inode_info 里面的函数或者
</span>    <span class="c1">// 进程唤醒, 这里是函数还是进程由注册的时候的决定
</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">do_wakeup</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">wake_up_interruptible_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
      <span class="n">kill_fasync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">fasync_writers</span><span class="p">,</span> <span class="n">SIGIO</span><span class="p">,</span> <span class="n">POLL_OUT</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="err">最后的</span><span class="n">wake_up</span> <span class="err">函数其实最后会调用到</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__wake_up_common</span><span class="p">(</span><span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span>
      <span class="kt">int</span> <span class="n">nr_exclusive</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>

<span class="err">这个函数里面去了</span><span class="p">,</span> <span class="err">然后最后的调用是</span>
    <span class="cm">/*
     * 这里的func 默认会调用到default_wake_function, 因为在wait_queue_t
     * 初始化的时候回设置func = default_wake_function
     * 如果有注册函数就执行对应的注册函数
     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">wake_flags</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_FLAG_EXCLUSIVE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!--</span><span class="n">nr_exclusive</span><span class="p">)</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
<span class="err">就是执行注册的函数</span>

</code></pre>
</div>

<p>最后就会调用wake_up_interruptible_sync, 这个就把pipe_inode_info 上面的wait_queue_head_t 上面的等待进程队列唤醒, 那么这里pipe-&gt;wait 上面的这个等待队列是什么时候加上去的呢?</p>

<p>说明每一个文件都有这个文件的唤醒队列, 当这个文件有操作的时候, 会通过wake_up 操作来将这个唤醒队列的进程给唤醒,</p>

<h4 id="section-1">那么一般是怎么加入到这个唤醒队列里面的呢?</h4>

<p>首先是注册到这个fd 的wait_queue_t 里面</p>

<p>过程是在epoll_insert 的时候会调用一下这个pipe fd的poll() 函数
这里在epoll 里面会调用</p>

<p>revents = tfile-&gt;f_op-&gt;poll(tfile, &amp;epq.pt);</p>

<p>这个操作就是将当前的进程加入到tfile 这个fd 的唤醒队列里面去.</p>

<p>对应于在pipe 里面的调用就是</p>

<p>pipe_poll(struct file *filp, poll_table *wait)</p>

<p>然后在pipe_poll 里面调到的最重要的是</p>

<p>poll_wait(filp, &amp;pipe-&gt;wait, wait);</p>

<p>poll_wait 本质到最后调用的是ep_ptable_queue_proc函数, 因为在epoll 调用tfile-&gt;f_op-&gt;poll 的时候已经注册了这个回调函数</p>

<p>static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,
         poll_table *pt)
{</p>

<h4 id="pollselect-">为什么说 poll/select 的性能比较低</h4>

<ol>
  <li>在poll/select 的实现里面, 如果监听多个fd, 只要其中有一个fd 有事件达到, 那么久遍历一个list 去检查到底是哪一个事件到达, 并没有像epoll 一样将这些fd 放在一个红黑树上</li>
</ol>

<div class="highlighter-rouge"><pre class="highlight"><code>
  <span class="cm">/*
   * 程序在这里面schedule_timeout 中sleep, 如果有事件到达,
   * 从schedule_timeout中唤醒, 然后重新执行逻辑
   */</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">rinp</span><span class="p">,</span> <span class="o">*</span><span class="n">routp</span><span class="p">,</span> <span class="o">*</span><span class="n">rexp</span><span class="p">,</span> <span class="o">*</span><span class="n">inp</span><span class="p">,</span> <span class="o">*</span><span class="n">outp</span><span class="p">,</span> <span class="o">*</span><span class="n">exp</span><span class="p">;</span>

		<span class="n">inp</span> <span class="o">=</span> <span class="n">fds</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">;</span> <span class="n">outp</span> <span class="o">=</span> <span class="n">fds</span><span class="o">-&gt;</span><span class="n">out</span><span class="p">;</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">fds</span><span class="o">-&gt;</span><span class="n">ex</span><span class="p">;</span>
		<span class="n">rinp</span> <span class="o">=</span> <span class="n">fds</span><span class="o">-&gt;</span><span class="n">res_in</span><span class="p">;</span> <span class="n">routp</span> <span class="o">=</span> <span class="n">fds</span><span class="o">-&gt;</span><span class="n">res_out</span><span class="p">;</span> <span class="n">rexp</span> <span class="o">=</span> <span class="n">fds</span><span class="o">-&gt;</span><span class="n">res_ex</span><span class="p">;</span>

    <span class="cm">/*
     * 这里检查监听的所有的fd 的状态, 如果这个fd 有事件, 就把对应的rinp, routp,
     * rexp 进行修改
     * 这里可以看到, 即使只有一个fd有事件到达, 这里也要把所有的fd 都遍历一遍,
     * 这就是性能很低的原因了
     */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">rinp</span><span class="p">,</span> <span class="o">++</span><span class="n">routp</span><span class="p">,</span> <span class="o">++</span><span class="n">rexp</span><span class="p">)</span> <span class="p">{</span>

</code></pre>
</div>

<ol>
  <li>在进行select 的过程中, 是先将要监听的fd 从用户空间拷贝到内核空间, 然后在内核空间里面进行修改以后, 在拷贝回去给用户空间. 这里就设计到内核空间申请内存, 释放内存等等过程</li>
</ol>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">core_sys_select</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">fd_set</span> <span class="n">__user</span> <span class="o">*</span><span class="n">inp</span><span class="p">,</span> <span class="n">fd_set</span> <span class="n">__user</span> <span class="o">*</span><span class="n">outp</span><span class="p">,</span>
			   <span class="n">fd_set</span> <span class="n">__user</span> <span class="o">*</span><span class="n">exp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">end_time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fd_set_bits</span> <span class="n">fds</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">bits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">max_fds</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fdtable</span> <span class="o">*</span><span class="n">fdt</span><span class="p">;</span>
  <span class="c1">// 可以看到select 是先尝试分配空间在栈上, 下面代码可以看出加入这个需要监听的fd
</span>  <span class="c1">// 比较多, 那么就会去申请堆空间里面的内容
</span>  <span class="c1">// 这里SELECT_STACK_ALLOC 默认是 256, 那么也就是这个当监听的fd
</span>  <span class="c1">// 的个数小于256个的时候, 这里的空间实在栈上,
</span>  <span class="c1">// 如果大于256其实空间实在堆上面申请的
</span>	<span class="cm">/* Allocate small arguments on the stack to save memory and be faster */</span>

	<span class="kt">long</span> <span class="n">stack_fds</span><span class="p">[</span><span class="n">SELECT_STACK_ALLOC</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">)];</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_nofds</span><span class="p">;</span>

	<span class="cm">/* max_fds can increase, so grab it once to avoid race */</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">fdt</span> <span class="o">=</span> <span class="n">files_fdtable</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">);</span>
	<span class="n">max_fds</span> <span class="o">=</span> <span class="n">fdt</span><span class="o">-&gt;</span><span class="n">max_fds</span><span class="p">;</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">max_fds</span><span class="p">)</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">max_fds</span><span class="p">;</span>

	<span class="cm">/*
	 * We need 6 bitmaps (in/out/ex for both incoming and outgoing),
	 * since we used fdset we need to allocate memory in units of
	 * long-words. 
	 */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">FDS_BYTES</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
	<span class="n">bits</span> <span class="o">=</span> <span class="n">stack_fds</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">stack_fds</span><span class="p">)</span> <span class="o">/</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Not enough space in on-stack array; must use kmalloc */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">bits</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="mi">6</span> <span class="o">*</span> <span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bits</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_nofds</span><span class="p">;</span>
	<span class="p">}</span>
  <span class="cm">/*
   * 这里分别为in, out, ex, res_in, res_out, res_ex 初始化指针到对应的空间里面
   *
   * 我们经常说的select 需要拷贝这个fd 值得就是这里,
   * 就是将用户空间注册的要监听的fd inp, outp, exp 拷贝到fds.in, fds.out,
   * fds.ex. 然后这些fd 的事件的结果我们保存在 fds.res_in, fds.res_out,
   * fds.res_ex. 然后再将这里面的内容拷贝回去到用户空间 inp, outp, exp
   */</span>
	<span class="n">fds</span><span class="p">.</span><span class="n">in</span>      <span class="o">=</span> <span class="n">bits</span><span class="p">;</span>
	<span class="n">fds</span><span class="p">.</span><span class="n">out</span>     <span class="o">=</span> <span class="n">bits</span> <span class="o">+</span>   <span class="n">size</span><span class="p">;</span>
	<span class="n">fds</span><span class="p">.</span><span class="n">ex</span>      <span class="o">=</span> <span class="n">bits</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">size</span><span class="p">;</span>
	<span class="n">fds</span><span class="p">.</span><span class="n">res_in</span>  <span class="o">=</span> <span class="n">bits</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">size</span><span class="p">;</span>
	<span class="n">fds</span><span class="p">.</span><span class="n">res_out</span> <span class="o">=</span> <span class="n">bits</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">size</span><span class="p">;</span>
	<span class="n">fds</span><span class="p">.</span><span class="n">res_ex</span>  <span class="o">=</span> <span class="n">bits</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="n">size</span><span class="p">;</span>

  <span class="cm">/*
   * 这里就是我们经常说的select需要去用户空间拷贝内容的代码
   * 这里就是把存在inp 里面注册的内容拷贝到 fds.in 里面
   */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">get_fd_set</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">fds</span><span class="p">.</span><span class="n">in</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">ret</span> <span class="o">=</span> <span class="n">get_fd_set</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">outp</span><span class="p">,</span> <span class="n">fds</span><span class="p">.</span><span class="n">out</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">ret</span> <span class="o">=</span> <span class="n">get_fd_set</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">fds</span><span class="p">.</span><span class="n">ex</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">zero_fd_set</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">fds</span><span class="p">.</span><span class="n">res_in</span><span class="p">);</span>
	<span class="n">zero_fd_set</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">fds</span><span class="p">.</span><span class="n">res_out</span><span class="p">);</span>
	<span class="n">zero_fd_set</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">fds</span><span class="p">.</span><span class="n">res_ex</span><span class="p">);</span>

  <span class="cm">/*
   * 这里是最主要的select 的过程了
   * ret 返回的是当前有事件的fd 的个数
   */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">do_select</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fds</span><span class="p">,</span> <span class="n">end_time</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTNOHAND</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

  <span class="cm">/*
   * 这里就是讲内核空间fds.res_in, out, ex里面的内容拷贝回去到inp, outp, exp
   * 的过程
   */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">set_fd_set</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">fds</span><span class="p">.</span><span class="n">res_in</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">set_fd_set</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">outp</span><span class="p">,</span> <span class="n">fds</span><span class="p">.</span><span class="n">res_out</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">set_fd_set</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">fds</span><span class="p">.</span><span class="n">res_ex</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">!=</span> <span class="n">stack_fds</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">bits</span><span class="p">);</span>
<span class="nl">out_nofds:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

</code></pre>
</div>


</article>






  <div id="disqus_thread"></div>
  <script type="text/javascript">
    var disqus_shortname  = 'baotiao';
    var disqus_identifier = '/2016/03/06/epoll_implementation';
    var disqus_title      = 'epoll implementation';

    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>






      </div>
    </div>
  </div>

  <footer class="center">
</footer>


</body>
</html>
