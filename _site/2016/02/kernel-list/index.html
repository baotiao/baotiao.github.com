<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="author" content="陈宗志" />
	<title>kernel list | 陈宗志</title>
    <link rel="shortcut icon" href="/favicon.ico">
    <link href="http://baotiao.github.io/feed/" rel="alternate" title="陈宗志" type="application/atom+xml" />
    <link rel="stylesheet" href="/media/css/style.css">
    <link rel="stylesheet" href="/media/js/code/desert.css">|
  </head>

	<div id="top"></div>
  <body>
    <div id="container">
      <div id="main" role="main">
        <header>
        <h1>kernel list</h1>
        </header>

        <nav>
        <span><a title="home page" class="" href="http://baotiao.github.io/">home</a></span>
        <span><a title="categories" class="" href="http://baotiao.github.io/categories/">categories</a></span>
        <span><a title="links" class="" href="http://baotiao.github.io/links/">links</a></span>
        <span><a title="paper" class="" href="http://baotiao.github.io/paper/">paper</a></span>
        <span><a title="vitae" class="" href="http://baotiao.github.io/vitae/">vitae</a></span>
        </nav>

        <article class="content">


        <section class="post">
<h3>困惑点</h3>

<p>之前看kernel list 的时候困惑的地方在于这个list里面居然没有指针指向这个list
对应的struct, 而是直接指向struct 里面的list 元素,
比如这样</p>

<pre><code>struct my_cool_list{
  struct list_head list; /* kernel's list structure */
  int my_cool_data;
  void* my_cool_void;
};
</code></pre>

<p>那么怎么返回这个实际包含这个list 里面的元素的struct 的结构体呢?</p>

<p>答案: 其实最重要的一点就是有list_entry(ptr, type, member) 这个宏定义,
这个宏实现可以从一个struct 里面的一个元素, 然后返回这个struct 的地址,
这个是怎么做的呢?</p>

<p>其实也很好实现, 就是把struct 里面的偏移量拿来加减就可以了, 比如
struct node {
  int a;
  int b;
}</p>

<p>知道这个node.b 的地址, 那么很容易根据偏移量减去这个地址就可以了. 所以</p>

<pre><code>#define list_entry(ptr, type, member) \
        ((type *)((char *)(ptr)-(unsigned long)(&amp;((type *)0)-&gt;member)))
</code></pre>

<p>这里ptr 就是这个b 的地址, 然后type 就是这个node 这个结构体, member 就是这个b.</p>

<p>那么这里我们是怎么知道b 这个元素在这个结构体里面的偏移量呢?</p>

<p>Now the question is how can we compute the offset of an element in a structure? Suppose you have a data structure struct foo_bar and you want to find the offset of element boo in it, this is how you do it:
(unsigned long)(&amp;((struct foo_bar *)0)->boo)</p>

<p>这样就可以了
这里的做法就是用foo_bar 结构体指针指向这个0这个地址, -> boo的操作其实就是增加这个偏移量, 然后获得这个元素的地址了</p>

<p>其他的地方就是普通的list 结构, 然后封装好了比较方便的操作了
<img src="http://i.imgur.com/513DxAK.jpg" alt="Imgur" /></p>

<h3>kernel list 好在哪里呢?</h3>

<p>我们平常自己实现的list 一般是这么实现的</p>

<pre><code>
struct my_list{
  void *myitem;
  struct my_list *next;
  struct my_list *prev;
};
</code></pre>

<p>这里我们想要获得下一个list元素, 一般有一个对应struct 类型的指针 *next;<br/>
然后这个next 指针一般指向下一个my_list;</p>

<p>然而kernel 里面的list 是这么实现</p>

<pre><code>struct my_cool_list{
  struct list_head list; /* kernel's list structure */
  int my_cool_data;
  void* my_cool_void;
};
</code></pre>

<p>这里可以看到相比较于我们自己实现的list, kernel list 的优点有</p>

<ol>
<li>直接把这个list_head 结构体放在一个struct 内部, 就可以让这个struct 实现一个list 结构, 不需要知道这个struct 的类型, 实现的非常的通用, 这里也可以在这个 把这个list 连接的不是这个my_cool_list 类型, 连接其他类型也是完全可以</li>
<li>可以放多个list_head 结构, 这样这个结构体就可以连成多个list, 虽然原生的方法也可以, 不过这样看上去非常的简洁</li>
</ol>


<p>这个是list 的具体使用方法,</p>

<pre><code>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include "list.h"

struct kool_list{
  int to;
  struct list_head list;
  int from;
};

int main(int argc, char **argv){

  struct kool_list *tmp;
  struct list_head *pos, *q;
  unsigned int i;

  struct kool_list mylist;
  INIT_LIST_HEAD(&amp;mylist.list);
  /* or you could have declared this with the following macro
  * LIST_HEAD(mylist); which declares and initializes the list
   */

  /* adding elements to mylist */
  for(i=5; i!=0; --i){
    tmp= (struct kool_list *)malloc(sizeof(struct kool_list));

    /* INIT_LIST_HEAD(&amp;tmp-&gt;list);
    *
    * this initializes a dynamically allocated list_head. we
    * you can omit this if subsequent call is add_list() or
    * anything along that line because the next, prev
    * fields get initialized in those functions.
     */
    printf("enter to and from:");
    scanf("%d %d", &amp;tmp-&gt;to, &amp;tmp-&gt;from);

    /* add the new item 'tmp' to the list of items in mylist */
    list_add(&amp;(tmp-&gt;list), &amp;(mylist.list));
    /* you can also use list_add_tail() which adds new items to
    * the tail end of the list
     */
  }
  printf("\n");

  /* now you have a circularly linked list of items of type struct kool_list.
  * now let us go through the items and print them out
   */

  /* list_for_each() is a macro for a for loop.
  * first parameter is used as the counter in for loop. in other words, inside the
  * loop it points to the current item's list_head.
  * second parameter is the pointer to the list. it is not manipulated by the macro.
   */
  printf("traversing the list using list_for_each()\n");
  list_for_each(pos, &amp;mylist.list){

    /* at this point: pos-&gt;next points to the next item's 'list' variable and
    * pos-&gt;prev points to the previous item's 'list' variable. Here item is
    * of type struct kool_list. But we need to access the item itself not the
    * variable 'list' in the item! macro list_entry() does just that. See "How
    * does this work?" below for an explanation of how this is done.
     */
    tmp= list_entry(pos, struct kool_list, list);

    /* given a pointer to struct list_head, type of data structure it is part of,
    * and it's name (struct list_head's name in the data structure) it returns a
    * pointer to the data structure in which the pointer is part of.
    * For example, in the above line list_entry() will return a pointer to the
    * struct kool_list item it is embedded in!
     */

    printf("to= %d from= %d\n", tmp-&gt;to, tmp-&gt;from);

  }
  printf("\n");
  /* since this is a circularly linked list. you can traverse the list in reverse order
  * as well. all you need to do is replace 'list_for_each' with 'list_for_each_prev'
  * everything else remain the same!
  *
  * Also you can traverse the list using list_for_each_entry() to iterate over a given
  * type of entries. For example:
   */
  printf("traversing the list using list_for_each_entry()\n");
  list_for_each_entry(tmp, &amp;mylist.list, list)
    printf("to= %d from= %d\n", tmp-&gt;to, tmp-&gt;from);
  printf("\n");

  /* now let's be good and free the kool_list items. since we will be removing items
  * off the list using list_del() we need to use a safer version of the list_for_each()
  * macro aptly named list_for_each_safe(). Note that you MUST use this macro if the loop
  * involves deletions of items (or moving items from one list to another).
   */
  printf("deleting the list using list_for_each_safe()\n");
  list_for_each_safe(pos, q, &amp;mylist.list){
    tmp= list_entry(pos, struct kool_list, list);
    printf("freeing item to= %d from= %d\n", tmp-&gt;to, tmp-&gt;from);
    list_del(pos);
    free(tmp);
  }

  return 0;
}
</code></pre>

</section>
<section class="meta">
<span class="author">
  <a href="http://baotiao.github.io/">陈宗志</a>
</span>
<span class="time">
  /
  <time datetime="2016-02-28">2016-02-28</time>
</span>
<br />
<span class="license">
  Published under <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">(CC) BY-NC-SA</a>
</span>

<span class="categories">
  in categories
  
  <a href="http://baotiao.github.io/categories/#kernel, tech" title="kernel, tech">kernel, tech</a>&nbsp;
  
</span>


<span class="tags">
  tagged with 
  
  <a href="http://baotiao.github.io/tags/#kernel" title="kernel">kernel</a>&nbsp;
  
</span>

</section>

<div class="bshare-custom"><a title="åäº«å°æ°æµªå¾®å" class="bshare-sinaminiblog"></a><a title="åäº«å°Facebook" class="bshare-facebook"></a><a title="åäº«å°Twitter" class="bshare-twitter"></a><a title="æ´å¤å¹³å°" class="bshare-more bshare-more-icon more-style-addthis"></a></div><script type="text/javascript" charset="utf-8" src="http://static.bshare.cn/b/buttonLite.js#style=-1&amp;uuid=17304268-f570-4255-9088-f5132e6fd01b&amp;pophcol=1&amp;lang=zh"></script><script type="text/javascript" charset="utf-8" src="http://static.bshare.cn/b/bshareC0.js"></script>
<section class="comment">
<div id="disqus_thread"></div>
<script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'baotiao'; // required: replace example with your forum shortname
		var disqus_rul = 'http://baotiao.github.io/2016/02/kernel-list/';

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
</section>

<script type="text/javascript">
$(function(){
  $(document).keydown(function(e) {
    if (e.target.nodeName.toUpperCase() != 'BODY') return;
    var url = false;
        if (e.which == 37 || e.which == 74) {  // Left arrow and J
            
        url = 'http://baotiao.github.io/2016/02/kernel-file-poll-operations/';
        
        }
        else if (e.which == 39 || e.which == 75) {  // Right arrow and K
            
        url = 'http://baotiao.github.io/2016/03/epoll_implementation/';
        
        }
        if (url) {
            window.location = url;
        }
  });
})
</script>



        </article>

	<div id="message"><a href="#top">Scroll to top</a></div>
	</div>
</div>

<script type="text/javascript" src="/media/js/jquery-1.7.1.min.js"></script>
<script type="text/javascript" src="/media/js/code/prettify.js"></script>

 <script type="text/javascript">
      $(function(){
        $("pre").addClass("prettyprint");
        prettyPrint();
        $('.entry a').each(function(){
          if($(this).attr("href").indexOf("chenzongzhi") == -1){
            $(this).attr("target", "_blank");
          }
        })
      });
</script>


<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-35023741-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>



<script type="text/javascript">
$(function () {

    /* set variables locally for increased performance */
    var scroll_timer;
    var displayed = false;
    var $message = $('#message a');
    var $window = $(window);
    var top = $(document.body).children(0).position().top;

    /* react to scroll event on window */
    $window.scroll(function () {
        window.clearTimeout(scroll_timer);
        scroll_timer = window.setTimeout(function () {
            if($window.scrollTop() <= top + 800)
            {
                displayed = false;
                $message.fadeOut(1000);
            }
            else if(displayed == false)
            {
                displayed = true;
                $message.stop(true, true).show().click(function () { $message.fadeOut(1000); });
            }
        }, 100);
    });
});
</script>
  </body>
</html>
