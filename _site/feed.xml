<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>baotiao</title>
    <description>做有积累的事情</description>
    <link>http://baotiao.github.io//</link>
    <atom:link href="http://baotiao.github.io//feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Linux physical page note</title>
        <description>&lt;h3 id=&quot;linux-page-frame-management&quot;&gt;linux page frame management&lt;/h3&gt;

&lt;p&gt;物理内存的管理最基本的概念就是 page frame, zone.&lt;/p&gt;

&lt;p&gt;然后物理内存的地址也是从0 开始, 其中其实的一部分内存会有特殊的用途, 比如第一个page frame 就是用来给BIOS 系统用来记录系统的硬件配置的的, 比如640KB 到 1MB 的内存在兼容IBM的机器里面都是没用的.&lt;/p&gt;

&lt;p&gt;那么这些内存信息是怎么获得的呢? 是在boot 阶段通过machine_specific_memory_setup() -&amp;gt; setup_memory() 函数来获得的.  在执行setup_memory() 完成以后, 会同时执行去获得一些参数的设定, 为的是更好的管理这个物理内存&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/do8QNwb.jpg&quot; alt=&quot;Imgur&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面是内存从0~3M 的物理内存的布局, 可以看出&lt;/p&gt;

&lt;p&gt;_text ~ _etext 是内核的代码段, 内核的data 区分成了两个部分, 一部分是initialized, 一部分是 uninitialized. initialized 在 _etext ~ _edata 之前, uninitialized 在 _edata ~ _end 区间&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/7MbmEXF.jpg&quot; alt=&quot;Imgur&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么上下文切换的代价比价高?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;因为每一个进程都有自己的page tables, 然后TLB 保存的是linear address =&amp;gt; physical address 的映射cache,  TLB 就是一层缓存, 一旦反思context switch 以后, 缓存里面的内容就清空了, 也就无法使用了, 因此上下文切换以后又要重新填充缓存里面的内容, 因此切换成本是比较高的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在linux 里面如何管理这些page frames?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这个page frame 结构体用 mmzone.h:struct page 来维护的, 然后所有的page 是通过全局变量 mem_map 来把所有的page frame 连在一起的, 这个 page 结构体里面的flag 表示这个page 目前的状态, 是否是dirty, 是否可以reclaim 等等, 应该是最重要的结构体了&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这些page frame 都存在zone 里面的zone_mem_map 里面了&lt;/p&gt;

&lt;p&gt;mmzone.h:extern struct page *mem_map;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/2l2SuxJ.jpg&quot; alt=&quot;Imgur&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/lrzFJt9.jpg&quot; alt=&quot;Imgur&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/EFucoxv.jpg&quot; alt=&quot;Imgur&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在linux 里面是根据 zone 来进行page frame 的管理的,  在每一个zone 内部都通过buddy system algorithm 来进行页的管理, 那么具体的每一个页存在哪里呢?&lt;/p&gt;

&lt;p&gt;可以从申请物理内存的这几个申请函数来看, 主要由这几个方法, alloc_pages, alloc_page, __get_free_pages, __get_free_page&lt;/p&gt;

&lt;p&gt;这里申请physical address 就设计到了 page reclaim, water mark 等等这些东西了, 主要通过 __alloc_pages_nodemask 来申请, 具体的每一个page frame 是存在两个&lt;/p&gt;

&lt;p&gt;所有的pages 是根据zone来管理, 那么对应的page 在mmzone.h:struct zone:free_area[MAX_ORDER] 里面, 可以看到, 根据buddy system algorithm 每一个层级大小的page 都有一个list, 然后有请求的时候就去对应大小的list 里面去申请(这里free_area 结构同时记录了当前这个list 有多少的free number). 然后在kernel 做page reclaim 的时候, 每一个page 又被两个list 连在一起, 一个list 是 free, 一个 list 是used, 所以page frame 这个struct 上才有一堆&lt;/p&gt;

&lt;p&gt;真正的alloc_page, __get_free_pages 等函数到最后都是调用__rmqueue() 从对应的zone 里面的free_area 里面去获得对应大小的page, 那么__rmqueue() 是如何做的呢?&lt;/p&gt;

&lt;p&gt;这里我们知道,&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;最近看管理物理内存这块, 有一个困惑 &lt;/p&gt;

  &lt;p&gt;我们知道kernel 申请物理内存的时候是在不同的zone 上面去申请, zone 里面有 zone_mem_map 连接着所有的page frame 信息, 然后从这个zone 里面的free_area  根据 Buddy algorithm 去获得对应大小的页.  我的问题是 那这些zone 的信息是存在哪, 因为zone 这个结构体是提供后续kernel 有内存申请操作的时候, 由zone 提供的,  所以我想zone 应该是在bootloader 阶段就初始化好的. 然后这个zone 对应的结构的应该是固定在物理内存的某一个位置, 是这样理解么?&lt;/p&gt;

  &lt;p&gt;所以就是内核在初始化的时候会初始化pglist_data 这个变量, 这个变量存在就是所有zone 的list.&lt;/p&gt;

  &lt;p&gt;static int __build_all_zonelists(void *data)&lt;/p&gt;

  &lt;p&gt;这个函数里面就是初始化这个zonelists,&lt;/p&gt;

  &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;for_each_online_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;pg_data_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pgdat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NODE_DATA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  
  
&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pglist_data&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contig_page_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define NODE_DATA(nid)		(&amp;amp;contig_page_data)
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pglist_data&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__refdata&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contig_page_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bdata&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bootmem_node_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;bootmem_data_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bootmem_node_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX_NUMNODES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__initdata&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  
&lt;span class=&quot;c1&quot;&gt;// 这里有__initdata 标识的就是在boot 阶段初始化的data, 所以是保存在内核代码的_data 区域也就是静态全局变量区
// 具体可以看 include/linux/init.h
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/tdRlX2S.jpg&quot; alt=&quot;Imgur&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;内核申请的物理内存是否和用户空间申请的物理内存在不同的位置?&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在kernel 内部申请的physical address 和在用户空间申请 physical address 是走一样的流程么? 他们保存的地址是一样的么. 其实用户空间申请的malloc 最后也是调用brk, brk 底下也是调用__alloc_pages_nodemask() 来申请了&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;嗯嗯  跟你确认一下 其实对于物理内存来说, 用户空间通过malloc 到 brk 最后什么的物理内存 和 kernel 空间申请的物理内存其实是一样的对吧, brk 最后肯定也有调用 page_alloc() 函数, 唯一不一样的时候 gfp_mask 不一样而已吧&lt;/p&gt;

  &lt;p&gt;那有一个问题  所谓的内核保护只是虚拟内存的保护, 实际物理内存也是没做什么保护的, 因为其实在物理内存上 内核空间和用户空间是并没有区分的, 还是存在用户空间映射的物理内存搞错了把内核空间的物理内存给写坏了的情况.  当然这里只是极端情况, 因为虚拟地址空间到物理地址空间的映射是内核自己控制的, 用户控制不了的, 所以只要这个映射方法没错, 还是可以起到保护作用的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;因为所有的 进程都共享 内核地址空间, 比如内核里面保存着所有的进程列表, 这些列表也是在zone 初始化完成以后, 从zone 里面的free_area 里面申请的内存吧. 所以这个zone 的初始化一定是最开始做的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其实主要的区别就是通过这个gfp_mask 来区分的,  比如有GFP_USER, GFP_KERNEL, 所以走的是一样的流程, 只是这个gfp_mask 不一样而已.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/In0neK1.jpg&quot; alt=&quot;Imgur&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/HACFIWZ.jpg&quot; alt=&quot;Imgur&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;kernel 的page table是保存在哪里的, 是如何维护的?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;那么问题来了, 这个kernel page table 到底有什么用?&lt;/p&gt;

&lt;p&gt;理论上因为所有进程的内核空间都一样, 那么就不需要kernel page table, 因为page table 的存在于用户空间的目的就是为了节省内存, 用比较小的内存来记录 linear address 到 physical address 的映射. 而所有的kernel 空间都一样的话, 就不需要这个了. 因为只需要一份就够了. 而不是用户空间的page table 一样, 每一个进程都需要有一份&lt;/p&gt;

&lt;p&gt;但是这里kernel 还是有这样的需求, 就是在物理内存上不是连续的空间, 但是kernel 还是需要在虚拟地址空间上提供一个连续的地址.  有了kernel page table 的存在, kernel page table 就可以做这个事情, 有kernel page table 提供映射, 在linear address 上是连续的, 而底下的physical address 是不连续的&lt;/p&gt;

&lt;p&gt;kernel page table 的地址是这个&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/*
 * 这里设置的是初始化时候的mm_struct 结构
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mm_struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;init_mm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mm_rb&lt;/span&gt;		&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RB_ROOT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pgd&lt;/span&gt;		&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;swapper_pg_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mm_users&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ATOMIC_INIT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mm_count&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ATOMIC_INIT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mmap_sem&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__RWSEM_INITIALIZER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;init_mm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mmap_sem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;page_table_lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;__SPIN_LOCK_UNLOCKED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;init_mm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;page_table_lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mmlist&lt;/span&gt;		&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LIST_HEAD_INIT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;init_mm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mmlist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cpu_vm_mask&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CPU_MASK_ALL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;后续实现vmalloc 的时候, 当我们需要修改进程的内核地址空间的时候, 都是去这个init_mm 上面去修改, 因此kernel page table 是存在这个init_mm 结构上的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;asm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;movl %%cr3,%0&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;=r&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pgd_paddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pgd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pgd_index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pgd_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__va&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pgd_paddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 
&lt;span class=&quot;n&quot;&gt;pgd_k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;init_mm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pgd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pgd_index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 这里init_mm.pgd + 当前这个地址的偏移量就是kernel 这个address 的偏移量地址
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;那么修改kernel page table 是什么时候呢?&lt;/p&gt;

&lt;p&gt;任何process 修改kernel page table 的时候都是修改master kernel page table, 然后在进程访问自己的page table的kernel 空间的时候, 触发缺页中断来处理. 在缺页中断的处理过程中, 上来会首先判断这个缺页中断是来自内核空间还是用户空间, 如果来自内核空间, 那么回去从master kernel page table 里面把这个内容拷贝过来&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/3ssZ2pi.jpg&quot; alt=&quot;Imgur&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;是否所有的进程都共享内核空间的地址?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;是, 有一个master kernel page table, 所有的改动都会改动到这个master kernel page table, 然后会同步到所有的其他进程上面. 但是每一个进程的pgd 都是自己4G 大小的空间的&lt;/p&gt;

&lt;p&gt;Whereas the lower part is modified during a context switch (between two user processes), the kernel part of virtual address space always remains the same. &lt;/p&gt;

&lt;p&gt;The kernel uses the auxiliary function vmalloc_fault to synchronize the page tables. I won’t show the code in detail because all it does is copy the relevant entry from the page table of init — this is the kernel master table on IA-32 systems — into the current page table. If no matching entry is found there, the kernel invokes fixup_exception in a final attempt to recover the fault; I discuss this shortly.&lt;/p&gt;

&lt;p&gt;说明这个master kernel page table 是保存在 init 进程的page table 里面的. 然后如果init 进程的master kernel page table 也没有这个从linear address 到 physical address 的映射, 那么就会调用fixup_exception() 函数来修补. 这个init 进程的mm_struct 是这样的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/*
 * 这里设置的是初始化时候的mm_struct 结构
 * 也是init 进程的 mm_struct 结构
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mm_struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;init_mm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mm_rb&lt;/span&gt;		&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RB_ROOT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pgd&lt;/span&gt;		&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;swapper_pg_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mm_users&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ATOMIC_INIT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mm_count&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ATOMIC_INIT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mmap_sem&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__RWSEM_INITIALIZER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;init_mm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mmap_sem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;page_table_lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;__SPIN_LOCK_UNLOCKED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;init_mm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;page_table_lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mmlist&lt;/span&gt;		&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LIST_HEAD_INIT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;init_mm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mmlist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cpu_vm_mask&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CPU_MASK_ALL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;kernel 是怎么分配物理内存的? 就是哪一部分物理内存分别用作什么?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/Q1fTnHL.jpg&quot; alt=&quot;Imgur&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里看到内核的代码是从第一个1M以后开始放的, 然后内核的代码的大小差不多只有2.5MB((00381ecc -00100000)/1024/1024), 然后kernel 的data 段差不多有0.9M&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么操作系统1G的linear address 要分成这么几个部分?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我的理解是比如前面的PAGE_OFFSET-&amp;gt;high_memory  这部分的直接映射是为了physical address -&amp;gt; linear address 非常的快, 不需要经过MMU, 必须要有一个page table 来做这个映射的过程.&lt;/p&gt;

&lt;p&gt;其实下面这个图获得不精确, 前面的PAGE_OFFSET ~ high_memory 其实占用了896M的内容, 从high_memory ~ 4G值占用了 128M 的内容&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/tQMWbTV.jpg&quot; alt=&quot;Imgur&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么内核的linear address 需要 high_mem 这样的地址空间&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这里这个概念需要理解一下 PAGE_OFFSET ~ high_memory 映射到物理内存的ZONE_HIGHMEM, 那么这里的问题就变成为什么需要ZONE_HIGHMEM?&lt;/p&gt;

&lt;p&gt;那我们就知道物理内存里面包含ZONE_DMA, ZONE_NORMAL, ZONE_HIGHMEM 这三个部分. (ZONE_NORMAL 也叫做low memory, ZONE_HIGHMEM 也叫做high memory)其中ZONE_NORMAL是映射到kernel linear address 里面的896M的内容, 那么物理内存里面超过896M以后的怎么办呢? 这部分的内容就主要是用户空间使用的内容了. 但是有一个问题是比如有2G的内存, 内核空间其实没有使用满896M的内容, 用户空间一直在使用内存, 这个时候用户空间的进程可以去使用这个896M里面的内容么? 应该是可以吧, 用户空间申请内存的时候是优先申请ZONE_HIGH, 如果没有其实也还是会向ZONE_HIGH 里面申请内存的&lt;/p&gt;

&lt;p&gt;其实这个映射896M的物理内存也不是从0开始的, 其实是从16M的地方开始的, 前面有一些内存用户kernel 代码段,  BIOS配置等等&lt;/p&gt;

&lt;p&gt;“High memory” and “low memory” do not apply to the virtual address space of processes, it’s about physical memory instead.&lt;/p&gt;

&lt;p&gt;Every article explains only the situation, when you’ve installed 4
 GB of memory and the kernel maps the 1 GB into kernel space and user processes uses the remaining amount of RAM.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么我们需要direct mapping, 并且这个896M的空间会不是一个浪费&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有了direct mapping 以后, 那是不是一种浪费, 比如在1G的内核空间里面, 有896M 虚拟内存空间被用作其他的用途了&lt;/p&gt;

&lt;p&gt;或者这么说这个direct mapping 跟kernel page table 的关系, 因为我们知道page table 就是用来确定linear address 和 physical address的关系的, 有了这个东西以后, 还需要kernel page table 了么?&lt;/p&gt;

&lt;p&gt;这里kernel page table 是必须存在的, 因为开启了保护模式以后, CPU发送出来的地址都是linear address, 需要通过MMU 进行linear address 到 physical address 的转换, 而这个转换又需要page table 的支持. 那为什么还需要这个direct mapping呢?&lt;/p&gt;

&lt;p&gt;其实direct mapping 和 kernel page table 都是提供了一种linear address 到 physical address 的一种映射. 用户空间只有page table 提供linear address 到 physical address 的映射, 内核空间增加了direct mapping 完全是为了方便, 因为直接用 linear address - 0xc0000000 就可以获得对应的physical address, 直接 + 0xc0000000 就可以获得对应的linear address. 不需要去查找page table, 而内核空间为了获得linear address 到 physical address 是需要去查这个page table 的. 但是有了这个方便也同样带来问题, 内核里面存在大量的这个 trade-off. 因为有了这个映射关系以后, kernel page table 的内存其实是提前确认下来的. 如果用户进程先使用了 这个物理地址, 当时这个kernel linear address 就不能用了, 那么就浪费了这个linear address.但是这个时候说明这个内存已经吃紧了, 因为正常用户优先从ZONE_HIGHMEM 去申请物理内存的. 同时, 如果没有这个映射关系 就不存在这个问题了, 其实这里也就是拿这个获得linear address 到 physical address 的方便和当内存不够用的时候, 浪费linear address 之间的一个trade off. 所以其实一定程度上也减少了这个kernel 使用Linea address 的自由&lt;/p&gt;

&lt;p&gt;其实这里的kernel page table 主要是为了处理vmalloc 这样的请求, 也就是在内核地址空间上是非连续的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么内核需要Persistent kernel mappings&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么内核需要Fix-mapped linear address&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么如果page frame 没有直接映射到kernel linear address 就无法使用呢?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;因为我们不管到哪一步返回物理地址的address 的时候也是一个0x… 这样的地址, 但是其实这样的地址内存是怎么识别的呢?&lt;/p&gt;

&lt;p&gt;因为内核开启了保护模式以后, CPU 发送出来的地址都是虚拟地址, 需要通过MMU 来进行地址转换&lt;/p&gt;

&lt;p&gt;但是page frame 映射到linear address 只是为了更方便的去请求这个physical address&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;page frame 是怎么和对应的物理内存建立关系的呢&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这里其实搞混了, 应该是struct page 如何和page frame(page frame 就是物理内存). 所以不要把struct page 和 page frame 搞混.&lt;/p&gt;

&lt;p&gt;其实所谓的alloc_pages, __get_free_page 等等这些函数最后所获得的东西都是这个struct page, 包括Buddy system 等等所管理的也是这个struct page, 每一个物理的 page 都有一个这个struct page进行管理着. 然后后续真的访问的时候是通过这个page fault 来进行真的访问物理内存, 缺页中断的时候是 Linear address 去page table 里面去查找有没有对应的 pte, 如果没有就去申请&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;virtual address 真正和 physical address 建立关系的时候&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The association between virtual and physical memory is not established until the data of an area are actually needed. If a process accesses a part of virtual address space not yet associated with a page in memory, the processor automatically raises a &lt;em&gt;page fault&lt;/em&gt; that must be handled by the kernel.&lt;/p&gt;

&lt;p&gt;这里建立联系指的是通过__get_free_page(), page_allocs() 申请函数么? 应该是, 所以一般这个__get_free_pages(), page_alloc() 等等一般都是在page fault 的时候被调用的, 因为page fault 的时候才是真正的分配物理内存的时候, 然后这个pte 里面一般都是直接存的是physical 的地址, 而不是page frame 的地址, 因此经常有page frame 与 physical address 的转换过程.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;当缺页中断的时候, 返回回来的是physical address 么&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;确认一下缺页中断要做的事情是更新page table 里面的内容, 那么page table 里面具体的内容是什么呢? 存的应该是物理内存的地址吧, 嗯应该是 physical address, 然后如果想知道这个physical address 的情况, 可以通过查找对应struct page 来知道&lt;/p&gt;

&lt;p&gt;确认, 返回回来的是 physical address&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在内核里面struct page 是如何和physical page(page frame) 管理起来的&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;struct page 里面并没有address 说我这个struct page 对饮的physical page 是在哪里, 而是因为mem_map(struct page 构成的数组) 数组和物理内存是一一对应的, 我们知道mem_map 地址 对应的物理内存的其实地址, 那么每一个page 在mem_map 对应的偏移量就是对应的物理页对应物理内存的偏移量了, 因此通过简单的加减就可以得到了. virt_to_page(addr) 做的就是这个事情, 通过pfn_to_virt(pfn) 就是从physical page 到 struct page&lt;/p&gt;

&lt;p&gt;因为每一个物理的page frame 都有一个struct page 关联, 然后所有的struct page 组成一个mem_map 这个数组,  然后可以通过virt_to_page(address), pfn_to_virt(pfn) 来进行转换, 也就是说我们知道了struct page 是可以直接找到具体的物理内存的地址的.&lt;/p&gt;

&lt;p&gt;上面这段话哪里不对? 不对的地方在于这里只是struct page 和 page frame 的映射, 并没有linear address 和 physical address 的映射. 这里只是解决了page frame 和 struct page 的相互关系. 所以这里要记住有两个mapping关系 一个是struct page 和 page frame 的映射关系, 一个是linear address 和physical address的映射(linear address 和physical 通过page table 映射)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么内核有了kernel page table还需要有direct mapping&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们知道kernel 里面有896M 的direct mapping 部分对吧, 那既然kernel 已经有了direct mapping 那么为什么还需要kernel page table(我们知道page table 存在的意义也是为了从linear address 映射到 physical address).&lt;/p&gt;

&lt;p&gt;因为一旦开了分页，CPU就无法直接访问物理地址了，必须要走MMU.&lt;/p&gt;

&lt;p&gt;使用MMU, 而MMU 是根据页表进行寻址的, 所以kernel page table 存在的意义就是提供给 MMU寻址方式&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/6VDAfAA.jpg&quot; alt=&quot;Imgur&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面这张图可以看出cpu 访问内存的方式都是通过virtual address 的方式, 然后MMU(Address translation) 通过page table 去获得对应的physical address.&lt;/p&gt;

&lt;p&gt;Dedicated hardware on the CPU chip called the memory management unit (MMU) translates virtual addresses on the fly, using a look-up table stored in main memory whose contents are managed by the operating system.&lt;/p&gt;

&lt;p&gt;这里可以看出MMU 是一个专门的硬件, 然后这个page table 是存在内存里面的&lt;/p&gt;

&lt;p&gt;有一个要注意的是用户空间的进程访问内存都是通过page table 来进行访问的, 并不需要关注NODE_NORMAL, NODE_HIGH. 只是在申请内存的时候优先从某一个区域申请罢了&lt;/p&gt;

&lt;p&gt;所以可以说direct mapping 只是为了内核获得某一个linear address 对应physical address 比较方便的一个方法&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这个mem_map 一般保存在哪里&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个mem_map 在有了zone 以后是每一个zone 有自己的mem_map. 然后这个mem_map 一般保存在ZONE_NORMAL 的起始位置, 也就是位置一定是定好的&lt;/p&gt;

&lt;p&gt;and all the structs are kept in a global mem map array, which is usually stored at the beginning of ZONE NORMAL or just after the area reserved for the loaded kernel image in low memory machines. &lt;/p&gt;

&lt;p&gt;the global mem map is treated as a virtual array starting at PAGE OFFSET.&lt;/p&gt;

&lt;p&gt;也就是说mem_map 是从PAGE_OFFSET 这个位置开始的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关于page table 分配内存的时机&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;由于不管是kernel 还是用户空间的page table, 由于这个page table 只是负责linear address 到physical address. 所以也只是在需要的时候实时申请就可以了&lt;/p&gt;
</description>
        <pubDate>Thu, 18 May 2017 00:00:00 +0800</pubDate>
        <link>http://baotiao.github.io//2017/05/18/linux-physical-page-FAQ/</link>
        <guid isPermaLink="true">http://baotiao.github.io//2017/05/18/linux-physical-page-FAQ/</guid>
      </item>
    
      <item>
        <title>Paper Review - Amazon Aurora</title>
        <description>&lt;h3 id=&quot;paper-review-amazon-aurora&quot;&gt;[Paper review] Amazon Aurora&lt;/h3&gt;

&lt;p&gt;最近Amazon 在 SIGMOD 发了AWS 上面号称比mysql 快5倍的RDS Aurora 的论文. 当年Amazon 发布Dynamo的论文时候, 让大家知道了原来Nosql 还可以这么搞, 就有了后来的百家齐放, 不知道Aurora 的效果如何.&lt;/p&gt;

&lt;p&gt;Aurora 主要结构由 database 和 storage service 组成&lt;/p&gt;

&lt;p&gt;Aurora 使用叫做以服务为中心的架构设计. 其实就是 database 节点都是无状态节点, 也就是只包含了(SQL + Transactions) 这两层. 所有的数据都存在storage service.  这里的storage service 使用的是Amazon S3 服务.&lt;/p&gt;

&lt;p&gt;Aurora 的核心思想还是把 sql 里面的计算和存储分开, 并且是直接通过修改mysql 5.6 代码的方法. 看图1 里面的核心架构就可以看得出来, 但是这样带来的问题是之前 中心化的结构都在单机上, 肯定没有问题, 那么这样计算和存储拆开以后, 性能问题如何解决, 所以一开始论文也是, 到最后瓶颈就在网络上了&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/6xY047A.jpg&quot; alt=&quot;Imgur&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从上图可以看出AZ 有主从结构, 然后所有&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;那么接下来就是如何持久化数据的问题.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Aurora 提供的也是Quorum 机制, Qurora 认为(2 + 2 &amp;gt; 3) 的quorum 机制是不安全的, 因此使用的是 (4 + 3 &amp;gt; 6) 的副本机制, 数据分布在3个AZ(Availability zone)(可以理解为Amazon 的每一个机房), 每一个Availability Zone 里面有两个副本的数据. 为什么2 + 2 &amp;gt; 3 的quorum 不安全呢?&lt;/p&gt;

&lt;p&gt;在AZ A, B, C 三个副本的情况下, 每一个AZ 肯定都存在一些坏盘情况存在, 这个时候后台正在修复这些数据, 如果这个时候 AZ C 由于某些原因整个AZ挂了, 那么这个时候这些正在后台修理的这部分数据就无法满足 2/3 的Quorum, 因为可能这个数据写入在AZ C, 同时另一个副本在AZ A, 但是这块盘坏了,  剩余的一个在AZ B 里面的数据我们不知道是否是最新的, 只能等AZ C 恢复我们才能够知道.&lt;/p&gt;

&lt;p&gt;因此我们使用 (4 + 3 &amp;gt; 6) 的机制, 这样能够处理即使整个AZ 都坏了, 并且有一个副本坏了, 也不影响一致性.  因此有了数据分布在3个AZ, 每个AZ有两个副本的设计. 这样的设计肯定能够保证在坏掉一个AZ 和一个storage node 的时候可以保证正常的读取, 在挂掉任意两个storage node 的时候能够保证写入.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;另外一个就是数据恢复时间的问题?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了解决数据恢复时间比较慢的问题, 将数据切成了10G 大小的PG(Protection Group), 和分片一样. 为什么要切的这么小呢?&lt;/p&gt;

&lt;p&gt;为了保证模型的可靠性, 那么我们必须满足连续两次的平均失效时间(MTTF Mean Time to Failure)小于修复他们其中任何一个的平均修复时间(MTTR Mean Time to Repair), 这也能理解 因为如果修复时间不能小于这个连续连个的失败时间, 就有可能照成第3个节点, 第4个节点失败, 而修复还没有结束, 那么就无法保证上诉的4/6 的qurom 的要求了.&lt;/p&gt;

&lt;p&gt;那么如何减小MTTF 比较麻烦, 那么我们就想办法加快MTTR, 做法就是把数据裁剪成10G 大小的PG(Protection Groups), 这样对于一个PG 修复的时间在万兆网卡下, 差不多10s能够恢复.&lt;/p&gt;

&lt;p&gt;什么时候我们能看到这种问题呢? 因为10G segment 可以在10 内修复. 那么我们需要有2个node 在10s 同时出错, 并且有一个不包含他们两个的AZ 也同时出错, 才会出问题. 这个在我们观察到的可能性很小&lt;/p&gt;

&lt;p&gt;综上 storage service 整体架构&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/BhzOkP3.jpg&quot; alt=&quot;Imgur&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看出Aurora AZ是有主从结构的存在, 数据被切分成多个PG(Protection Groups), 每一个PG 由6个segment 组成, segment大小是10G. 每个PG的6个segment分散在3个AZ 中, 每一个AZ的storage node 由多个 segment 组成, 所有的这些PG 的redo log最后都会存储在Amazon S3上&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;接下来就是核心叫 The log is the database&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;熟悉Raft 协议的同学就不会陌生, 就是raft 协议里面Log 和状态机的关系. 只要顺序apply log, 那么就可以生成对应时刻的状态机. 在Aurora 里面log 就是mysql 的redo log, 状态机就是这个Segment. 当然Aurora 并没有使用Raft/Multi-paxos 协议, 但是我感觉有点类似, 我们下面分析.&lt;/p&gt;

&lt;p&gt;每一条redo log 有一个唯一的单调递增的 Log Sequence Number(LSN), 这个LSN 是由database 来生成, 从上面的架构图看估计是Dynamo DB. spanner 里面用的是时间戳.&lt;/p&gt;

&lt;p&gt;每一个独立的storage node 都需要保留自己的redo log stream, Aurora 认为 2PC 太繁琐,  容错太差, 因为写入并没有走2PC. 写入是Quorum 的, 不会保证每一个storage node 都有完整的redo log stream. 然后Aurora 通过gossip 协议不断去把每一个storage node 里面空缺的redo log 补上, 并更新DB 里面的内容. 这里就更Multi-Paxos 的写入过程基本一样&lt;/p&gt;

&lt;p&gt;storage service 会确认一个最大的保证之前操作都已经写入的 LSN VCL(Volume Complete LSN). 像Raft 里面的log 一样, 可能存在写入的log, 最后没提交的情况.&lt;/p&gt;

&lt;p&gt;database 会通过标记的LSN 来对这些log 进行截断, 这种标记的LSN 叫做CPL(consistency Point LSNs), 这些CPL 里面比VCL 小的最大的那个叫做VDL(Volume Durable LSNs).  这个就跟Raft 里面的全局commit Index 类似. 一般每一个MTR(mini-transactions) 里面的最后一个记录是一个CPL.&lt;/p&gt;

&lt;p&gt;SCL(segment complete LSN) 记录着每一个segment 已经确认commit 的 LSN, 相当于raft 里面的每一个节点自己的commit Index. Aurora 也会使用这个commit Index 来进行节点间交互去补齐log.&lt;/p&gt;

&lt;p&gt;那么事务commit 的过程就是这样, 每一个事务都有一个对应”commit LSN”, 那么这个事务提交以后就去做其他的事情, 什么时候通知这个事务已经提交成功呢? 就是当VDL(VDL 由databse 来发送, storage service来确认更新) 大于等于”commit LSN” 以后, 就会有一个专门的线程去通知这个等待的client, 你这个事务已经提交完成了.&lt;/p&gt;

&lt;p&gt;如果这个事务提交失败, 那么接下来的Recovery 是怎么处理的呢?&lt;/p&gt;

&lt;p&gt;首先这个Recovery 是由storage node 来处理的,  是以每一个PG 为维度进行处理, 在database 起来的时候通过 quorum 读取足够多的副本, 然后根据副本里面的内容得到VDL, 因为每一个时候最后一条记录是一个CPL, 这些CPL 里面最大的就是VDL,  然后把这个VDL 发送给其他的副本, 把大于VDL 的redo log 清除掉, 然后恢复这个PG的数据&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;亮点&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;项目直接从mysql 5.6 版本的代码剥离出来, 那么这样的换, SQL 协议兼容这块会做的比较容易了.&lt;/li&gt;
  &lt;li&gt;计算和存储分开, 目前是这些分布式系统的通用实现了吧&lt;/li&gt;
  &lt;li&gt;Aurora 用了大量AWS 内部非常成熟的服务, 和 spanner-sql 类似, 目前来看基于稳定的Nosql 去实现Newsql 大家基本都是这个路子. 当然得有一个足够稳定的底层存储才行.&lt;/li&gt;
  &lt;li&gt;每一个Protect Group 的内容是一个状态机, 对应的redo log 保存在Amazon S3 里面, 只需要通过顺序apply redo log 的内容就可以恢复这个Protect Group&lt;/li&gt;
  &lt;li&gt;将redo log 做成异步, 这样带来好处可以惰性更新. 读取的时候如果这个page 还有没apply 的redo log, 就等待redo log apply 完成. 还有就是Rocovery 的时候非常的快, 不需要等redo log apply 完成再起来. 其实这又和raft 里面log 和 状态机的关系一样&lt;/li&gt;
  &lt;li&gt;支持分布式的事务并没有通过2PC, 而是通过gossip+Quorum 机制来保证(跟Dynamo 通过gossip 来保证元信息的一致性一样的暴力, 哈哈), 在加上每一个redo log 有一个唯一的LSN 等等机制来实现强一致. 当然其实这里已经很类似raft 协议了&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;不过整个文章都没有讲到针对这种将storage, log 与计算层面分离以后, SQL 层面针对性的改动, 因为如果有范围查询的话以前在单机就本地执行就好, 但是现在这种架构需要生成多个请求去不同的storage-node 去请求数据. 倒是 Spanner: Becoming a SQL System 有大量的介绍, 回头可以看看&lt;/p&gt;

</description>
        <pubDate>Wed, 17 May 2017 00:00:00 +0800</pubDate>
        <link>http://baotiao.github.io//2017/05/17/amazon-aurora/</link>
        <guid isPermaLink="true">http://baotiao.github.io//2017/05/17/amazon-aurora/</guid>
      </item>
    
      <item>
        <title>linux write 落盘问题</title>
        <description>&lt;h3 id=&quot;data-to-disk&quot;&gt;data to disk&lt;/h3&gt;

&lt;p&gt;数据写到磁盘的一个级别问题&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/Kj4jvOF.jpg&quot; alt=&quot;Imgur&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个是一次write 写入经过的路径&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The client sends a write command to the database (data is in client’s memory).&lt;/li&gt;
  &lt;li&gt;The database receives the write (data is in server’s memory).&lt;/li&gt;
  &lt;li&gt;The database calls the system call that writes the data on disk (data is in the kernel’s buffer).&lt;/li&gt;
  &lt;li&gt;The operating system transfers the write buffer to the disk controller (data is in the disk cache).&lt;/li&gt;
  &lt;li&gt;The disk controller actually writes the data into a physical media (a magnetic disk, a Nand chip, …).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总结:&lt;/p&gt;

&lt;p&gt;当我们到第3 步, 也就是write 操作系统返回的时候, 可以保证的是如果process 挂了, 但是操作系统没挂, 这个数据我们是能够刷回磁盘的.&lt;/p&gt;

&lt;p&gt;当我们到了第4步, 也就是write 操作, 并且fsync了. 这个时候我们可以保证就算机器挂了, 数据也会写到disk controller. 这个时候正常情况下disk controller 是会保证数据刷回到物理介质的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;那么在第三步write 写入到page cache, page cache 是什么时候刷回磁盘的, 以及我们在上层怎么控制这个刷盘的策略呢?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;具体在2.6.32 这个版本,  主要的刷盘进程是sync_supers 这个进程, 这个和之前版本的pdflush 进程不一样, 之前版本主要有pdflush 负责刷盘操作&lt;/p&gt;

&lt;h3 id=&quot;kernel-bdi-module&quot;&gt;kernel bdi module&lt;/h3&gt;

&lt;p&gt;通过 cat /proc/meminfo | grep Dirty 可以看到Dirty page 有多少个&lt;/p&gt;

&lt;p&gt;backing_dev_info: 一个块设备都会包含一个backing_dev_info, 通常是块设备的request queue 会包含 backing_dev 对象&lt;/p&gt;

&lt;p&gt;bdi_writeback: 具体执行write_back 线程的封装, bdi_writeback 回去wb_writeback_work 里面取出元素, 然后拿来执行&lt;/p&gt;

&lt;p&gt;bdi_writeback_work: 就是具体的每一次的writeback 任务的抽象, 不同的任务可以采用不同的刷新策略, 下图一看到bdi_writeback_work 是挂载backing_dev_info 下面的, bdi_writeback 是从backing_dev_info 下面work_list 去看, 这个队列是否是空的, 如果不是空的就从里面拉出bdi_writeback_work 来消费, 这里bdi_writeback_work 在2.6.32 版本里面是有 wb_writeback_args, bdi_work 组成&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/jqTVSMo.jpg&quot; alt=&quot;Imgur&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;backing_dev_info&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_head&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bdi_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rcu_head&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rcu_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ra_pages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;cm&quot;&gt;/* max readahead in PAGE_CACHE_SIZE units */&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;cm&quot;&gt;/* Always use atomic bitops on this */&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;capabilities&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* Device capabilities */&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;congested_fn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;congested_fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* Function pointer if device is md/dm */&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;congested_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;cm&quot;&gt;/* Pointer to aux data for congested func */&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unplug_io_fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;backing_dev_info&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;page&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unplug_io_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;percpu_counter&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bdi_stat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NR_BDI_STAT_ITEMS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prop_local_percpu&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;completions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dirty_exceeded&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min_ratio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max_ratio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max_prop_frac&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bdi_writeback&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;cm&quot;&gt;/* default writeback info for this bdi */&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;spinlock_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wb_lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	  &lt;span class=&quot;cm&quot;&gt;/* protects update side of wb_list */&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_head&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wb_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* the flusher threads hanging off this bdi */&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wb_mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	  &lt;span class=&quot;cm&quot;&gt;/* bitmask of registered tasks */&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wb_cnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	  &lt;span class=&quot;cm&quot;&gt;/* number of registered tasks */&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_head&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;work_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;device&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;#ifdef CONFIG_DEBUG_FS
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dentry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;debug_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dentry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;debug_stats&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bdi_writeback&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_head&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;			&lt;span class=&quot;cm&quot;&gt;/* hangs off the bdi */&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;backing_dev_info&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bdi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;cm&quot;&gt;/* our parent bdi */&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last_old_flush&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;cm&quot;&gt;/* last old data flush */&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task_struct&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;cm&quot;&gt;/* writeback task */&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_head&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;b_dirty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;cm&quot;&gt;/* dirty inodes */&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_head&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;b_io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;cm&quot;&gt;/* parked for writeback */&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_head&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;b_more_io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;cm&quot;&gt;/* parked for more writeback */&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/*
 * Passed into wb_writeback(), essentially a subset of writeback_control
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wb_writeback_args&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nr_pages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;super_block&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writeback_sync_modes&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sync_mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;for_kupdate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;range_cyclic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;for_background&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/*
 * Work items for the bdi_writeback threads
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bdi_work&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_head&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;cm&quot;&gt;/* pending work list */&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rcu_head&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rcu_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;cm&quot;&gt;/* for RCU free/clear of work */&lt;/span&gt;

	&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;cm&quot;&gt;/* threads that have seen this work */&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;atomic_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pending&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;cm&quot;&gt;/* number of threads still to do work */&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wb_writeback_args&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;cm&quot;&gt;/* writeback arguments */&lt;/span&gt;

	&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;cm&quot;&gt;/* flag bits, see WS_* */&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;bdi_forker_task 在每一个back device 加入以后都会启动一个, bdi_fork_task() 函数没有任何的中途退出机制, bdi_fork_task() 的唯一用途就是检查是否需要启动对应的 flush 线程.&lt;/p&gt;

&lt;p&gt;所以默认的启动线程的顺序是通过bdi_register 在backing-dev 模块启动的时候就会启动一个 bdi-default 线程, 这个线程执行的是bdi_forker_task()方法, 这个线程负责启动每一个设备上面的flush- 线程, 这个flush 线程的执行的是bdi_start_fn-&amp;gt;bdi_writeback_task-&amp;gt;bdi_writeback_task(这个方法是一个循环, 直到5分钟没有需要flush 的page, 然后退出)-&amp;gt;wb_do_writeback(这个是具体的刷盘的逻辑, 根据这个来判断是否要退出上层的bdi_writeback_task逻辑)-&amp;gt;wb_writeback()-&amp;gt;writeback_inodes_wb()&lt;/p&gt;

&lt;p&gt;另外一个默认启动的线程是 sync_super 线程, 这个线程是去定期将superblock 里面的内容刷新回去&lt;/p&gt;

&lt;p&gt;关于 writeback 主要可以通过/sys/vm/ 配置的参数列表&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/* The following parameters are exported via /proc/sys/vm */&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/*
 * Start background writeback (via writeback threads) at this percentage
 */&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dirty_background_ratio&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/*
 * dirty_background_bytes starts at 0 (disabled) so that it is a function of
 * dirty_background_ratio * the amount of dirtyable memory
 */&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dirty_background_bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; 
  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;这里&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dirty_background_bytes&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;和&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dirty_background_ratio&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;的关系就是下面的这个几行代码&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;如果设置了&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dirty_background_bytes&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;就是用&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dirty_background_bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;否则就用&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dirty_background_ratio&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;available_memory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;所以默认&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dirty_background_bytes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dirty_background_bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;background&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DIV_ROUND_UP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dirty_background_bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PAGE_SIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;background&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dirty_background_ratio&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;available_memory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;


&lt;span class=&quot;cm&quot;&gt;/*
 * free highmem will not be subtracted from the total free memory
 * for calculating free ratios if vm_highmem_is_dirtyable is true
 */&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vm_highmem_is_dirtyable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/*
 * The generator of dirty data starts writeback at this percentage
 */&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vm_dirty_ratio&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/*
 * vm_dirty_bytes starts at 0 (disabled) so that it is a function of
 * vm_dirty_ratio * the amount of dirtyable memory
 * 同样 vm_dirty_bytes 和 vm_dirty_ratio 的关系是如果设置了 vm_dirty_bytes 就是用 vm_dirty_bytes, 否则就是用 vm_dirty_ratio
 if (vm_dirty_bytes)
	dirty_total = vm_dirty_bytes / PAGE_SIZE;
else
	dirty_total = (vm_dirty_ratio * determine_dirtyable_memory()) /
			100;
 
 */&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vm_dirty_bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/*
 * The interval between `kupdate&#39;-style writebacks
 * 启动后台flush 线程的时间, 后台默认是5 秒
 */&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dirty_writeback_interval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* centiseconds */&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/*
 * The longest time for which data is allowed to remain dirty
 * 这里就是脏数据能在内存中呆的最长的时间, 默认是 30s, 在进行wb_writeback 函数周期性的刷盘的时候判断这个数据是否是旧数据, 超过这个时间的数据才进行刷盘操作
 */&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dirty_expire_interval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* centiseconds */&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/*
 * Flag that makes the machine dump writes/reads and block dirtyings.
 */&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block_dump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/*
 * Flag that puts the machine in &quot;laptop mode&quot;. Doubles as a timeout in jiffies:
 * a full sync is triggered after this time elapses without any disk activity.
 */&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;laptop_mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;EXPORT_SYMBOL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;laptop_mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;dirty_background_ratio 和 dirty_ratio 的关系?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;dirty_background_ratio 是当系统里面的dirty page 超过这个百分比以后, 系统开始启动flush 进程将dirty page  flush 到磁盘&lt;/p&gt;

&lt;p&gt;dirty_ratio 是当系统里面的dirty page 超过这个百分比以后, 有写磁盘操作的进程会被阻塞, 等待将dirty page flush到磁盘以后再写入&lt;/p&gt;

&lt;p&gt;通过dd 修改不同的 dirty_ratio 来测试性能来看,  dirty_ratio 如果设置的比较小, 那么就很容易阻塞进程的写入所以性能比较低&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;┌─[chenzongzhi@bada05] - [/data5]
└─[$] sudo sh -c &#39;echo 0 &amp;gt;/proc/sys/vm/dirty_ratio&#39;
┌─[chenzongzhi@bada05] - [/data5]
└─[$] cat /proc/sys/vm/dirty_ratio
0
┌─[chenzongzhi@bada05] - [/data5]
└─[$] dd if=/dev/zero of=file-abc bs=1M count=30000
^C828+0 records in
828+0 records out
868220928 bytes (868 MB) copied, 158.016 s, 5.5 MB/s
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果把dirty_ratio 调整的比较大, 那么dd 的速度就会快很多, 基本上能够达到磁盘写的性能&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;┌─[chenzongzhi@bada05] - [/data5]
└─[$] sudo sh -c &#39;echo 100 &amp;gt;/proc/sys/vm/dirty_ratio&#39;
┌─[chenzongzhi@bada05] - [/data5]
└─[$] sudo sh -c &#39;echo 3 &amp;gt;/proc/sys/vm/drop_caches&#39;
┌─[chenzongzhi@bada05] - [/data5]
└─[$] dd if=/dev/zero of=file-abc bs=1M count=30000
dd: warning: partial read (339968 bytes); suggest iflag=fullblock
29999+1 records in
29999+1 records out
31456571392 bytes (31 GB) copied, 104.62 s, 301 MB/s
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;THE PROBLEM
~~~~~~~~~~~

Each block device has corresponding &quot;flusher&quot; thread, which is usually seen as &quot;flusher-x:y&quot; in your &#39;ps&#39; output. Flusher threads are responsible for
background write-back and are used in various kernel code paths like memory
reclamation as well as the periodic background write-out.

The flusher threads wake up every 5 seconds and check whether they have to
write anything back or not. In idle systems with good dynamic power-management this means that they force the system to wake up from deep sleep, find out that there is nothing to do, and waste power. This hurts small battery-powered
devices, e.g., linux-based phones.

Idle bdi thread wake-ups do not last forever: the threads kill themselves if
nothing useful has been done for 5 minutes.

However, there is the bdi forker thread, seen as &#39;bdi-default&#39; in your &#39;ps&#39;
output. This thread also wakes up every 5 seconds and checks whether it has to fork a bdi flusher thread, in case there is dirty data on the bdi, but bdi
thread was killed. This thread never kills itself, and disturbs the system all the time. Again, this is bad for battery-powered devices.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;到3.10.0 版本以后, 这个bdi-default 线程, flush 线程什么也都没有了, 都变成kworker, 然后把需要flush 的任务丢到这个kworker 队列里面就可以了&lt;/p&gt;

&lt;p&gt;3.10.0 里面&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;bdi_wq&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alloc_workqueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;writeback&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WQ_MEM_RECLAIM&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WQ_FREEZABLE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
				      &lt;span class=&quot;n&quot;&gt;WQ_UNBOUND&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WQ_SYSFS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;所以新版本的内核里面是看不到这些bdi, pdflush 等等. 这样做的好处也是很明显的, 不需要为了专门做flush 这个事情, 专门搞一个线程, 而且还需要经常去唤醒&lt;/p&gt;

&lt;h3 id=&quot;practices&quot;&gt;Practices&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;减少内存使用&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vm.dirty_background_ratio = 5
vm.dirty_ratio = 10
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;最大化的使用内存&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vm.dirty_background_ratio = 50
vm.dirty_ratio = 80
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;优化写入性能, 可以使用内存, 但是等到空闲的时候希望内存被回收, 比较经常用在应对突然有峰值的这种情况&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vm.dirty_background_ratio = 5
vm.dirty_ratio = 80
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 02 Mar 2017 00:00:00 +0800</pubDate>
        <link>http://baotiao.github.io//2017/03/02/data-to-disk/</link>
        <guid isPermaLink="true">http://baotiao.github.io//2017/03/02/data-to-disk/</guid>
      </item>
    
      <item>
        <title>page cache dirty_expire_interval</title>
        <description>&lt;p&gt;昨天分享&lt;a href=&quot;https://www.slideshare.net/baotiao/disk-and-page-cache&quot;&gt;disk and page cache&lt;/a&gt; 遗留了几个问题, 回去又看代码加实际验证了一下, 得到如下结论:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;dirty_expired_interval 确实和我们昨天所说的是一样的效果&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;从代码层面上来看, 所有的dirty_inode 会被放入到 bdi_writeback 这个结构体, 保存在 b_dirty 这个list 里面, 然后在进行queue_io() 的时候会比较这个 dirty_expire_interval, 只有超过这个时间的dirty inode 才会放入到b_io 这个lish 里面, 接下来对于在b_io 这个list 进行刷盘操作.&lt;/p&gt;

&lt;p&gt;从具体的验证层面来看, 我们写一个example&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;sys/time.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdint.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;NowMicros&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeval&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;gettimeofday&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tv_sec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000000&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tv_usec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;


&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;./czzres&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;O_RDWR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;O_CREAT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mo&quot;&gt;0644&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;st&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NowMicros&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;18&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;st&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NowMicros&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;snprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;%ld&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;st&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个程序做的事情只有一个, 一直获得当前的时间戳, 然后把当前的时间戳写到这个 czzres, 这个文件里面.&lt;/p&gt;

&lt;p&gt;然后我们做的事情就是让这个进程不断的写入数据, 然后突然将这个机器给关机, 然后记录关机的时间, 重启以后判断这个时间戳和我们关机的时间是否一致, 如果一直说明这个参数并不起作用, 如果里面的数据比我们关机的时间要来得晚, 这说明这个参数生效了&lt;/p&gt;

&lt;p&gt;验证的结果&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ww3.sinaimg.cn/large/006tNc79ly1fc1ucvhmcvj30ek07ldgg.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后对应的时间是 2017/1/24 17:1:31&lt;/p&gt;

&lt;p&gt;而我们的关机时间是&lt;/p&gt;

&lt;p&gt;[vagrant@haoli-d1 ~]$ date
Tue Jan 24 09:01:39 UTC 2017&lt;/p&gt;

&lt;p&gt;再次验证, 运行这个进程不到10s 以后, 直接重启机器, 在这个机器上甚至都没有生成过这个文件czzres, 进一步验证了我们的猜想&lt;/p&gt;

&lt;p&gt;调整dirty_expire_interval 为 5, 也就是50ms, 看是否生效&lt;/p&gt;

&lt;p&gt;得到的结论是czzres 里面的内容是&lt;/p&gt;

&lt;p&gt;1485250286839995
1485250286839996
1485250286839996 = 2017/1/24 17:31:26&lt;/p&gt;

&lt;p&gt;然后我们的时间date 是&lt;/p&gt;

&lt;p&gt;[vagrant@haoli-d1 ~]$ date
Tue Jan 24 09:31:44 UTC 2017&lt;/p&gt;

&lt;p&gt;证明也是生效的&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;结论&lt;/h3&gt;

&lt;p&gt;所以如果使用默认的配置, 也就是dirty_expired_interval, dirty_writeback_interval 分别是 30s, 5s 的时候, 那么最大有可能丢失的是35s 左右的数据.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;那为什么线上的pika, mysql 等等不会有这么大量的数据丢失呢?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;因为这些引擎内部默认都会主动的去调用fsync() 将脏数据刷到磁盘, 比如pika 的引擎rocksdb, 在每一次compact 生成文件以后是会将sst 文件主动调用fsync 刷新到磁盘的. 比如mysql 的innodb 引擎每次执行完一个事务以后, 也是主动的调用fsync, 写binlog 的时候也是每写一次就调用fsync, 因此不会有大量的数据丢失&lt;/p&gt;

&lt;p&gt;另外在page cache 的flush 策略里面, 如果一个文件有一个脏页, 那么他这个时候是将整个文件都进行flush 操作的, 而不是只flush 脏页的这一部分.&lt;/p&gt;

&lt;p&gt;并且智昊昨天问题如果一个文件不断的写入, 那么岂不是这个30s 永远都打不到了, 不是这样的, 这里只会记录第一次变dirty 的时间, 后续如果是dirty 就不再更新这个时间了, 见kernel mailing list&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Well, let me explain the mechanism in more detail: When the first page is dirtied in an inode, the current time is recorded in the inode. When this time gets older than dirty_expire_centisecs, all dirty pages in the inode are written. So with this mechanism in mind the behavior you describe looks expected to me.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Tue, 24 Jan 2017 00:00:00 +0800</pubDate>
        <link>http://baotiao.github.io//2017/01/24/page-cache/</link>
        <guid isPermaLink="true">http://baotiao.github.io//2017/01/24/page-cache/</guid>
      </item>
    
      <item>
        <title>leveldb code review</title>
        <description>&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;leveldb 一般用继承的时候只有接口继承, 比如DB 和 DBImpl, Comparator 和 BytewiseComparatorImpl 的关系, 然后同时会提供一个函数创建这些类别, 比如&lt;/p&gt;

    &lt;p&gt;extern const Comparator* BytewiseComparator();&lt;/p&gt;

    &lt;p&gt;返回一个BytewiseComparator() 给.h 文件对外暴露出去&lt;/p&gt;

    &lt;p&gt;基本上所有的include 下面都是提供接口继承的方式来使用, 然后在.h 文件提供创建接口&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对比block_builder.h 和 table_builder.h 可以发现, block_builder 并没有使用Pimpl 的形式来做, 因为block_builder.h 是给内部自己使用的, 而table_builder.h 是给外部使用的. 可以看到BlockBuilder 所有的函数都不需要virtual, 因为已经能够确认这些函数是给自己使用的&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在DB 里面的GetSnapshot() 确实返回就是类里面的一个成员变量的指针,&lt;/p&gt;

    &lt;p&gt;virtual const Snapshot* GetSnapshot() = 0;&lt;/p&gt;

    &lt;p&gt;那么这种唯一的做法只能是给返回的指针加 const&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关于virtual 的使用&lt;/p&gt;

    &lt;p&gt;因为提供的include 文件里面, 大量的都是提供接口继承方式,  所以需要使用virtual 修饰函数, 如果明确知道这个类不会被继承, 那么就不要使用virtual 来修饰函数, 因为毕竟 virtual 是有开销的&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果有一些常量只在某一个.cc 文件里面使用到, 那么可以只在这个.cc 文件里面去定义就可以了比如:
static const size_t kFilterBaseLg = 11;&lt;/p&gt;

    &lt;p&gt;static const int kTargetFileSize = 2 * 1048576;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;比如设计在函数内部会申请一个对象, 并且这个对象需要外部去删除, 那么最好在这个头文件的注释里面说明这个对象需要在外部显示的去调用delete&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;c1&quot;&gt;// Pick level and inputs for a new compaction.
// Returns NULL if there is no compaction to be done.
// 这里说明的返回的对象是在heap 上面创建的一个Compaction 对象,
// 并不是返回类里面的成员变量, 如果是这样的请求,
// 那么最好写好注释说明需要外部主动的释放申请的这个对象
// Otherwise returns a pointer to a heap-allocated object that
// describes the compaction.  Caller should delete the result.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Compaction&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PickCompaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 同意底下的compactRange 也一样, 返回的是在heap 上面申请的Compaction 对象, 外部函数需要负责删除
// Return a compaction object for compacting the range [begin,end] in
// the specified level.  Returns NULL if there is nothing in that
// level that overlaps the specified range.  Caller should delete
// the result.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Compaction&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CompactRange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
   &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;level&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;InternalKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;InternalKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 基本上leveldb 里面所有的指针都是在类里面进行一个new的操作
//   Iterator* result = NewMergingIterator(&amp;amp;icmp_, list, num);
// 然后作为这个函数的返回, 所以这个时候一定是在函数的头里面去声明当这个指针没用的时候, 跟上面的Compaction 对象一样, 需要显示的去删除掉
// Create an iterator that reads over the compaction inputs for &quot;*c&quot;.
// The caller should delete the iterator when no longer needed.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MakeInputIterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Compaction&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果确认某一个对象只可以指向传进来的某一个变量, 并且无法修改变量里面的内容, 那就必须使用&lt;/p&gt;

    &lt;p&gt;const Options* const options_;&lt;/p&gt;

    &lt;p&gt;TableCache* const table_cache_;&lt;/p&gt;

    &lt;p&gt;这里table_cache_的意思是你可以修改table_cache_ 里面的内容, 但是table_cache_ 必须是指向的初始化的时候传进来的table_cache&lt;/p&gt;

    &lt;p&gt;但是这个table_cache_ 的内容是可以被修改的&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在Iterator 里面的 EmptyIterator 和 env 里面的EnvWrapper 的用途?&lt;/p&gt;

    &lt;p&gt;在Iterator 问题中, 因为Iterator是以虚基类, 不能实例化, 因此在这样的函数中 NewMergingIterator, Block::NewIterator 函数中出错的时候如何返回一个指针, 因此需要一个EmptyIterator&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 这里当出错的时候就可以返回这个EmptyIterator() 了
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;NewMergingIterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Comparator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NewEmptyIterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MergingIterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;在EnvWrapper 里面把所有的Env 作为变量传入进来, 把所有的接口都实现了一边这个有什么用呢?&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EnvWrapper&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Env&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Initialize an EnvWrapper that delegates all calls to *t
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;explicit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EnvWrapper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Env&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EnvWrapper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;这样在实现一个新的Env 的时候, 可以只实现哪些想要实现的接口, 如果不想实现这个接口, 那么你的这个接口就是你默认传进来的那个Env* t 里面的那个实现
比如
class InmemoryEnv : public EnvWrapper {
}&lt;/p&gt;

    &lt;p&gt;然后这里InmemoryEnv 的构造函数是传进来的是 PoxisEnv, 那么这个时候如果我InmemoryEnv 里面不需要写任何东西, 这里InmemoryEnv 都包含了所有的PosixEnv 的实现. 所以是非常方便的, 但是也需要看到这里是有性能损失的&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在leveldb 的DB 类里面同样看到了基类是虚基类, 但是在实现子类的时候, 又去把虚基类里面的纯函数给实现的情况?&lt;/p&gt;

    &lt;p&gt;就像函数上面的注释所说的是为了方便集成下来子类有一个默认的实现方式, 同时又提醒子类必须自己去实现这个函数的一种做法&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Default implementations of convenience methods that subclasses of DB
// can call if they wish
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Status&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Put&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WriteOptions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;opt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Slice&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Slice&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;WriteBatch&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;batch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;batch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Put&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;opt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;batch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Status&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WriteOptions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;opt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Slice&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;WriteBatch&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;batch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;batch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;opt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;batch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为什么同样是接口类 db.h, iterator.h, filter_policy.h. 而只有db.h 里面提供static 方法来进行创建, 而iterator.h 和 filter_policy.h 都是提供在函数外的方法&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// db.h
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DB&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
 &lt;span class=&quot;c1&quot;&gt;// Open the database with the specified &quot;name&quot;.
&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Stores a pointer to a heap-allocated database in *dbptr and returns
&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// OK on success.
&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Stores NULL in *dbptr and returns a non-OK status on error.
&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Caller should delete *dbptr when it is no longer needed.
&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Status&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Options&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;DB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dbptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// filter_policy.h
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FilterPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NewBloomFilterPolicy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bits_per_key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// iterator.h
// db_impl.h:
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NewIterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ReadOptions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// two_level_iterator.h
// Return a new two level iterator.  A two-level iterator contains an
// index iterator whose values point to a sequence of blocks where
// each block is itself a sequence of ke	y,value pairs.  The returned
// two-level iterator yields the concatenation of all key/value pairs
// in the sequence of blocks.  Takes ownership of &quot;index_iter&quot; and
// will delete it when no longer needed.
//
// Uses a supplied function to convert an index_iter value into
// an iterator over the contents of the corresponding block.
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NewTwoLevelIterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index_iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block_function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;
       &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ReadOptions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Slice&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
   &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ReadOptions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;总结出来就是如果你只是实现接口, 并且只需要唯一的一个实现的话, 比如 db-&amp;gt;DBImpl, 那么只要在类里面提供一个静态的方法就可以, 如果DBImpl 有多种实现方式的话, 使用这种方式是有问题的, 因为各个使用方式里面都需要实现一个DB::Open 这个方法, 肯定有冲突的. 但是比如想Iterator, FilterPolicy 这种需要提供多种的实现方式的, 就在不同的方式里面提供一个不同的类似Create 的函数.&lt;/p&gt;

    &lt;p&gt;同时这里由于DB::Open() 这个函数需要访问类里面的私有成员函数, 因此必须写成类里面的静态成员函数才可以, 如果写成外部函数是不可以的&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 05 Jan 2017 00:00:00 +0800</pubDate>
        <link>http://baotiao.github.io//2017/01/05/leveldb-code-review/</link>
        <guid isPermaLink="true">http://baotiao.github.io//2017/01/05/leveldb-code-review/</guid>
      </item>
    
      <item>
        <title>cpp inheritance summary</title>
        <description>&lt;h4 id=&quot;inheritance--composition-&quot;&gt;关于inheritance 和 composition 对比&lt;/h4&gt;

&lt;p&gt;public inheritance 表示的是 is-a 的关系&lt;/p&gt;

&lt;p&gt;所有能够用在base class 上面的东西应该都可以使用到 derive class上, 	因为所有的derive class 都是base class的一种&lt;/p&gt;

&lt;p&gt;composition 有两个含义&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;表示的是has-a 的关系&lt;/li&gt;
  &lt;li&gt;表示由什么东西来实现&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里检查是否能够使用inheritance 的方法是. 是否所有客户端对base class 的操作都能够用到这个derive class 上, 并且不需要知道这个derive class 的具体实现细节.&lt;/p&gt;

&lt;p&gt;My suggestion is to enhance your “is a / has a” heuristic with the &lt;a href=&quot;http://www.objectmentor.com/resources/articles/lsp.pdf&quot;&gt;Liskov Substitution Principle&lt;/a&gt;.
To check whether an inheritence relationship complies with the Liskov Substitution Principle, ask whether clients of a base class can operate on the sub class without knowing that it is operating on a sub class. Of course, all the properties of the sub class must be preserved.&lt;/p&gt;

&lt;p&gt;有一个观点看来,  composition 的封装粒度要比 inheritance 来的更高,  因为 inheritance 需要知道更多基类的细节. 所以要判断需要使用composition 还是 inheritance 的时候, 先判断是否能够使用inheritance, 然后偏向于使用composition&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;在类里面通常有3个类型的函数&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;pure virtual function&lt;/li&gt;
  &lt;li&gt;non-pure virtual function&lt;/li&gt;
  &lt;li&gt;non-virtual function&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;pure virtual function 表示的是只继承这个接口, 并没有提供默认的实现&lt;/p&gt;

&lt;p&gt;常见的一个问题是有时候我们看到代码里面会有pure virtual function, 但是这个pure virtual function 又会有一个默认的实现, 为什么要这样写?&lt;/p&gt;

&lt;p&gt;比如rocksdb DB::Put 是pure virtual, 在DBImpl 里面有DB::Put的实现逻辑, 然后DBImpl::Put 只是去调用了一下这个DB::Put 方法. 这样方便如果又有DBImpl2 继承自 DBImpl, 需要写Put 的时候, 直接调用DB类提供的默认方法就可以了&lt;/p&gt;

&lt;p&gt;这里是希望的derive class 需要明确的去实现这个function, 而不是使用virtual function 那样有默认的实现方法. 但是又希望base class 给function 提供默认的实现的方法&lt;/p&gt;

&lt;p&gt;non-pure virtual function 表示的是继承这个接口并且给出了默认的实现&lt;/p&gt;

&lt;p&gt;non-virtual function 表示的是继承了这个接口并且强制了这个实现, 所以我们不应该在派生类里面去重新实现一个non-virtual function.&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;其他&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;在继承的时候, 只要继承virtual 和 pure-virtual 函数, 如果你要继承 non-virtual 函数, 这说明你的设计有问题了&lt;/li&gt;
  &lt;li&gt;在继承一个参数有默认值的函数的时候, 不要去修改这个函数的默认值, 因为这个默认值的绑定是随着这个类, 而这个函数的绑定是随着这个对象的&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 07 Dec 2016 00:00:00 +0800</pubDate>
        <link>http://baotiao.github.io//2016/12/07/cpp-inheritance/</link>
        <guid isPermaLink="true">http://baotiao.github.io//2016/12/07/cpp-inheritance/</guid>
      </item>
    
      <item>
        <title>talk about event based concurrency</title>
        <description>&lt;p&gt;&lt;strong&gt;比如像redis 单线程基于epoll 这种模型, node.js 这种模型都可以归结为Event-base Concurrency, 那么这种模型和multi-thread 对比有什么区别呢?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从调度角度来看multi-thread 是kernel 来决定下一个要调度处理的thread 是哪一个. 而kernel cpu scheduler 又是一个很大的模块, 很难肯定下一个要调度的thread 是哪一个.&lt;/p&gt;

&lt;p&gt;event-based 是当要监听的fd 有事情到达的时候, 由当前这个thread 来决定下一个要执行的event 是谁, 也就是说event-based 是可以实现用户自己决定下一个要执行的任务是谁. 比如简单的可以记录我这次到达的fd里面哪些是优先级高的fd即可.&lt;/p&gt;

&lt;p&gt;因为multi-thread 会考虑到每一个thread 的优先级等等, 而且如果thread 数目过多那么肯定会影响到具体的调度.虽然kernel scheduler 能够做到O(1) 的级别. 对比event-base, 切换线程需要切换上下文, 因此肯定会有性能的损耗.&lt;/p&gt;

&lt;p&gt;而在event-base 里面, 所有的event 的优先级都是一样的, 然后在处理event 的handler 里面决定先处理哪一个event. 但是同样有一个问题就是如果这个event-base 里面event 比较多, 那么性能肯定也会下来.&lt;/p&gt;

&lt;p&gt;那么event-base 缺点也有, 如果要使用多核的cpu的时候, 想要同时并行的运行多个event server 的时候, 需要用lock 进行同步的问题又来了.&lt;/p&gt;

&lt;p&gt;另外其实有些系统调用并不能支持异步, 比如如果一个处理 event handler 访问内存的时候触发了page fault, 那么这个时候是并不能把这个event handler 切换出去了, 必须等待这个page fault 执行完才可以. 所以kernel 还是不能做到全异步话, 还是有一些逻辑同步的.&lt;/p&gt;

&lt;p&gt;pink 里面的设计, 其实是综合上面考虑的结果, 不是一个纯 multi-thread, 也不是一个纯even based. 会有多个work thread, 然后每一个work thread 内部是event-base concurrency.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/XXfibpV.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 26 Nov 2016 00:00:00 +0800</pubDate>
        <link>http://baotiao.github.io//2016/11/26/concurrency/</link>
        <guid isPermaLink="true">http://baotiao.github.io//2016/11/26/concurrency/</guid>
      </item>
    
      <item>
        <title>将this 指针传给子类的问题</title>
        <description>&lt;h3 id=&quot;this-&quot;&gt;将this 指针传给子类的一些问题&lt;/h3&gt;

&lt;p&gt;最近实现代码的时候经常会遇到这种问题需要大量的将this指针传给类底下的成员变量, 因为成员变量需要用到父类里面的成员. 抽象出来是这种情况&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里A 类的两个子类 B, C 都会使用到A类里面的成员 d_, e_, str_. 所以我们经常要初始化的时候去给两个子类去传这个变量, 那么这个时候经常为了方便就直接将this 指针往下传, 变成这种&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;ceph 的代码里面就大量的这种将this 指针往下传的代码, 比如FileStore 里面sync_thread, op_wq 就是这种关系.&lt;/p&gt;

&lt;h4 id=&quot;this--1&quot;&gt;直接传this 指针有什么不好呢?&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;父类和子类互相依赖, 封装的不是很好&lt;/li&gt;
  &lt;li&gt;由于子类需要访问父类里面的成员, 常见的做法就是把这些变量做成public, 或者将B, C作为A类的friend 类, 这样就违反的封装的原则. 第一版floyd 就是这个做法&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RaftConsensus&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LeaderDiskThread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pink&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;LeaderDiskThread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RaftConsensus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;raft_con&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LeaderDiskThread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

		&lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ThreadMain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;RaftConsensus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;raft_con_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;LeaderDiskThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leader_disk_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;friend&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LeaderDiskThread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;friend&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ElectLeaderThread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;friend&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PeerThread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最简单的做法就是将B, C 类里面的内容往外提, 那么B, C类里面的内容就可以直接访问d_, e_, str_这些内容了, 但是更多的情况是 B, C 类是从其他类继承的, 这个时候就不能把B, C 类里面的内容往外提&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section&quot;&gt;那么比较好的解决方法是什么样子的呢?&lt;/h4&gt;

&lt;p&gt;我觉得leveldb 里面的Options 这个封装就比较好, Options 将需要访问的公共的成员变量都放在一个对象里面, 然后将Options 这个对象往子类传, 比如&lt;/p&gt;

&lt;p&gt;DBImpl 这个对象里面有 options, env_&lt;/p&gt;

&lt;p&gt;DBImpl 底下的TableCache, VersionSet 也需要这个options, env_ 这两个对象, 那么Leveldb 的做法就是将子类都需要访问的内容放在一起, 然后将这个对象以指针的形式往下传, 因为通常如果子类对这些对象进行了修改以后, 其他对象应该也是要能够看到的.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DBImpl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DB&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Env&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;env_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;InternalKeyComparator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;internal_comparator_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;InternalFilterPolicy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;internal_filter_policy_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Options&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;options_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// options_.comparator == &amp;amp;internal_comparator_
&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// table_cache_ provides its own synchronization
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;TableCache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table_cache_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;VersionSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;versions_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;TableCache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TableCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dbname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Options&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entries&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;env_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;dbname_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dbname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;options_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;cache_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewLRUCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;entries&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;VersionSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;VersionSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dbname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Options&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;TableCache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table_cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;InternalKeyComparator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;env_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;dbname_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dbname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;options_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;table_cache_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;table_cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;icmp_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;所以比较好的解决方法是把这些要把子类访问的对象放在一个struct 里面, 比如Options 这种, 或者像Env 这种里面都是一些Public的方法, 然后传给子类的对象自己去.&lt;/p&gt;

&lt;p&gt;这样写以后代码就清晰多了, 但是做的也就更细了&lt;/p&gt;

&lt;p&gt;所以还是看到一个东西是这个样子不重要, 最重要的应该是了解这个东西为什么是现在这个样子.&lt;/p&gt;
</description>
        <pubDate>Thu, 24 Nov 2016 00:00:00 +0800</pubDate>
        <link>http://baotiao.github.io//2016/11/24/cpp-pass-this/</link>
        <guid isPermaLink="true">http://baotiao.github.io//2016/11/24/cpp-pass-this/</guid>
      </item>
    
      <item>
        <title>cache policy</title>
        <description>&lt;h3 id=&quot;cache-policy&quot;&gt;cache policy&lt;/h3&gt;

&lt;p&gt;近期在做ceph cache-tier 相关的事情, 在cache-tier 里面cache有多种更新策略&lt;/p&gt;

&lt;p&gt;其实更缓存相关的系统里面, 都存在这几种策略, 比如操作系统的page cache,
业务层使用memcache, redis 作为后端数据库的缓存的时候,
也都要考虑缓存和后端存储的数据一致性问题. 其实就是更新操作的时候,
什么时候去更新缓存, 什么时候去更新后端存储的问题?&lt;/p&gt;

&lt;p&gt;那么这个时候一般会有3种策略&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;no-write&lt;/li&gt;
  &lt;li&gt;write-through&lt;/li&gt;
  &lt;li&gt;write-back&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;no-write&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;no-write 的实现方式是写入数据的时候是直接将数据写入到后端存储, 并且标记cache 中的数据是无效的, 那么后续的某一次读取发现无效以后, 会发起一次读取请求, 将后端存储中的数据更新到cache 中, 并且标记有效&lt;/p&gt;

&lt;p&gt;这个策略其实很少使用&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;write-through&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;write-through 实现方式是写入的时候将cache 和 后端存储的数据一起更新, 这种方法最能够保证cache 数据的一致性. 并且也是简单的方法, 但也是性能最低的一个方法&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;write-back&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;write-back 也是linux page cache采用的方式, 我觉得也是最通用的一种方式, 在write-back 策略里面, 写入操作是直接更新到cache 里面的,  后端存储不会马上更新. 然后这些需要更新的page 会被标记成dirty, 放到一个dirty list 里面, 然后周期性的有pdflush(2.6.32 以后就是flush per device)进行将cache 里面的数据刷回后端存储,  然后这些page 就不在标记dirty.&lt;/p&gt;

&lt;p&gt;write-back 方案可以看成是write-through 的一个优化版本,  其实就是通过lazy write 一次写入比较大的数据来提高这个写入的性能, 但是带来的问题可能就是缓存中的数据有可能丢失了. 所以在linux 里面可以通过fsync 来强制某一次的写入写到磁盘, 也就是从write-back 变成write-through了&lt;/p&gt;

</description>
        <pubDate>Wed, 14 Sep 2016 00:00:00 +0800</pubDate>
        <link>http://baotiao.github.io//2016/09/14/cache-policy/</link>
        <guid isPermaLink="true">http://baotiao.github.io//2016/09/14/cache-policy/</guid>
      </item>
    
      <item>
        <title>talk about kernel process descriptor</title>
        <description>&lt;h3 id=&quot;taskstruct-threadstruct-tssstruct-threadinfo-&quot;&gt;task_struct, thread_struct, tss_struct, thread_info 他们之间的关系是什么&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;task_struct&lt;/p&gt;

    &lt;p&gt;就是一个process descriptor&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task_struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;cm&quot;&gt;/* -1 unrunnable, 0 runnable, &amp;gt;0 stopped */&lt;/span&gt;
  &lt;span class=&quot;cm&quot;&gt;/*
   * 这个stack 里面存的内容就是内核空间的栈的内容
   * 内核空间的栈的内容包含两个部分
   * 1. thread_info
   * 2. kernel 里面的内核栈空间的内容
   *
   * 这个stack 的初始化是在fork.c:dup_task_struct:alloc_thread_info() 里面的
   * struct thread_info *ti;
   * tsk-&amp;gt;stack = ti;
   * 可以看出这个stack 指向的是一个thread_info 结构体
   *
   *  struct thread_info {
   *   struct task_struct	*task;		
   *   ...
   *   }
   *
   * task_thread_info(p)-&amp;gt;task = p;
   * 从这里又可以看出 这个thread_info-&amp;gt;task 又指向了这个task_struct
   * 也就是这两个结构体task_struct, thread_info是互相指向的
   * 为什么要这样做呢?
   * 因为cpu 里面的esp寄存器指向的就是kernel stack里面的内容, 然后通过kernel
   * stack 就可以获得thread_info 这个结构体(因为kernel stack 和 thread_info
   * 是保存在连续的8k 的空间上的),
   * 然后根据thread_info-&amp;gt;task就可以找到当前正在运行task_struct 了.
   */&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;cm&quot;&gt;/* CPU-specific state of this task */&lt;/span&gt;
  &lt;span class=&quot;cm&quot;&gt;/*
   * thread_struct 里面保留了大部分的cpu 寄存器的信息
   * 那么在context switch 的时候这个process 的cpu register
   * 等信息会被保存在这个thread_struct 里面
   */&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread_struct&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;tss_struct&lt;/p&gt;

    &lt;p&gt;是定义的Task State Segment, 也就是 TSS 段, 这个段的主要用在就是存 process context switch 上下文切换的时候的hardware context. 这个 tss_struct 保存在GDT(global descriptor table) 里面. 这个结构并不在task_struct 里面.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tss_struct&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tss&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;per_cpu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;init_tss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cpu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;从上面可以看出tss_struct 是每一个cpu 有一个这样的结构体&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;thread_struct&lt;/p&gt;

    &lt;p&gt;这个是 process context switch 的时候, 将 hardware context 主要保留在的地方, 每一个线程都包含一份 thread_struct. 当然还有一部分包含在 kernel mode stack 里面, 比如(eax, ebx 等等)&lt;/p&gt;

    &lt;p&gt;这里tss_struct 和 thread_struct 的关系是task_struct-&amp;gt;thread_struct 主要保留的是 context switch 后, 不在cpu中间运行的process的内容, 然后tss_struct 里面的内容是不是就是直接从task_struct-&amp;gt;thread_struct 里面的内容加载进来的呢? 确实是这样的&lt;/p&gt;

    &lt;p&gt;这里也可以看出在做process switch 的时候, 是先获得了要运行的下一个process 的task_struct, 然后从task_struct 里面的thread_struct 加载到GDT里面,&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;thread_info&lt;/p&gt;

    &lt;p&gt;thread_info 用来保存一些需要知道的固定变量, 类似写程序里面的全局变量&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;kernel mode stack&lt;/p&gt;

    &lt;p&gt;kernel mode stack 就是跟我们写程序的user mode stack 一样, 存的是一些临时变量, 和thread_info 相比, thread_info 更类似存全局变量&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;kernel-process--taskstruct-&quot;&gt;kernel 如何获得当前运行process 的 task_struct 的&lt;/h3&gt;

&lt;p&gt;这个就主要通过当前运行的process task_struct 里面的stack 来获得.&lt;/p&gt;

&lt;p&gt;在stack 里面是这样的一个结构&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/1fAYzia.jpg&quot; alt=&quot;Imgur&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看出这个stack 底下是一个thread_info 的结构体, 然后stack 的底部是在最上面, 这一部分就是kernel stack 的内容, esp 指针指向着当前的kernel stack 的头部. 那么这个时候想要获得当前运行process 的task_struct 就比较方便. 因为&lt;/p&gt;

&lt;p&gt;The close association between the thread_info structure and the Kernel Mode stack just described offers a key benefit in terms of efficiency: the kernel can easily obtain the address of the thread_info structure of the process currently running on a CPU from the value of the esp register.&lt;/p&gt;

&lt;p&gt;就是说可以通过esp 很容易获得thread_info 这个结构体的位置, 然后thread_info-&amp;gt;task 里面又保留了这个process descriptor 的指针就可以获得对应的task_struct 的位置了&lt;/p&gt;

&lt;h3 id=&quot;stack--threadinfo-page-&quot;&gt;为什么要把stack 和 thread_info 放在一个page 里面&lt;/h3&gt;

&lt;p&gt;Another advantage of storing the process descriptor with the stack emerges on multi-processor systems: the correct current process for each hardware processor can be derived just by checking the stack, as shown previously.&lt;/p&gt;

&lt;p&gt;Earlier versions of Linux did not store the kernel stack and the process descriptor together.&lt;/p&gt;

&lt;p&gt;因为kernel stack 上面永远放着esp指针, 那么因为esp 肯定在这个page里面, 通过取模很容易就可以获得当前这个thread_info 所在的地址, 通过thread_info 就可以很容易获得task_struct 的地址了&lt;/p&gt;

</description>
        <pubDate>Mon, 29 Aug 2016 00:00:00 +0800</pubDate>
        <link>http://baotiao.github.io//2016/08/29/process-descriptor/</link>
        <guid isPermaLink="true">http://baotiao.github.io//2016/08/29/process-descriptor/</guid>
      </item>
    
  </channel>
</rss>
